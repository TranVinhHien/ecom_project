// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: interact.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createCustomerFeedback = `-- name: CreateCustomerFeedback :exec

INSERT INTO customer_feedback (
    id,
    user_id,
    email,
    phone,
    category,
    content
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateCustomerFeedbackParams struct {
	ID       string         `json:"id"`
	UserID   sql.NullString `json:"user_id"`
	Email    sql.NullString `json:"email"`
	Phone    sql.NullString `json:"phone"`
	Category string         `json:"category"`
	Content  string         `json:"content"`
}

// =================================================================
// SQLC QUERIES FOR CUSTOMER_FEEDBACK
// =================================================================
func (q *Queries) CreateCustomerFeedback(ctx context.Context, arg CreateCustomerFeedbackParams) error {
	_, err := q.db.ExecContext(ctx, createCustomerFeedback,
		arg.ID,
		arg.UserID,
		arg.Email,
		arg.Phone,
		arg.Category,
		arg.Content,
	)
	return err
}

const createMessageRating = `-- name: CreateMessageRating :exec

INSERT INTO message_ratings (
    event_id,
    session_id,
    user_id,
    rating,
    user_prompt,
    agent_response
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateMessageRatingParams struct {
	EventID       string         `json:"event_id"`
	SessionID     string         `json:"session_id"`
	UserID        sql.NullString `json:"user_id"`
	Rating        int8           `json:"rating"`
	UserPrompt    sql.NullString `json:"user_prompt"`
	AgentResponse sql.NullString `json:"agent_response"`
}

// =================================================================
// SQLC QUERIES FOR MESSAGE_RATINGS
// =================================================================
func (q *Queries) CreateMessageRating(ctx context.Context, arg CreateMessageRatingParams) error {
	_, err := q.db.ExecContext(ctx, createMessageRating,
		arg.EventID,
		arg.SessionID,
		arg.UserID,
		arg.Rating,
		arg.UserPrompt,
		arg.AgentResponse,
	)
	return err
}

const getCustomerFeedbackByID = `-- name: GetCustomerFeedbackByID :one
SELECT id, user_id, email, phone, category, content, created_at, updated_at FROM customer_feedback
WHERE id = ?
`

// Lấy chi tiết 1 feedback
func (q *Queries) GetCustomerFeedbackByID(ctx context.Context, id string) (CustomerFeedback, error) {
	row := q.db.QueryRowContext(ctx, getCustomerFeedbackByID, id)
	var i CustomerFeedback
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.Phone,
		&i.Category,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerFeedbackStats = `-- name: GetCustomerFeedbackStats :one
SELECT
    COUNT(*) AS total_feedbacks,
    COUNT(CASE WHEN category = 'BUG' THEN 1 END) AS bug_count,
    COUNT(CASE WHEN category = 'COMPLAINT' THEN 1 END) AS complaint_count,
    COUNT(CASE WHEN category = 'SUGGESTION' THEN 1 END) AS suggestion_count,
    COUNT(DISTINCT user_id) AS unique_users
FROM customer_feedback
WHERE
    ? IS NULL 
    OR ? IS NULL 
    OR created_at BETWEEN ? AND ?
`

type GetCustomerFeedbackStatsParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetCustomerFeedbackStatsRow struct {
	TotalFeedbacks  int64 `json:"total_feedbacks"`
	BugCount        int64 `json:"bug_count"`
	ComplaintCount  int64 `json:"complaint_count"`
	SuggestionCount int64 `json:"suggestion_count"`
	UniqueUsers     int64 `json:"unique_users"`
}

// Thống kê tổng quan feedback
func (q *Queries) GetCustomerFeedbackStats(ctx context.Context, arg GetCustomerFeedbackStatsParams) (GetCustomerFeedbackStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerFeedbackStats,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
	)
	var i GetCustomerFeedbackStatsRow
	err := row.Scan(
		&i.TotalFeedbacks,
		&i.BugCount,
		&i.ComplaintCount,
		&i.SuggestionCount,
		&i.UniqueUsers,
	)
	return i, err
}

const getCustomerFeedbacksByCategory = `-- name: GetCustomerFeedbacksByCategory :many
SELECT
    category,
    COUNT(*) AS feedback_count
FROM customer_feedback
WHERE
    ? IS NULL 
    OR ? IS NULL 
    OR created_at BETWEEN ? AND ?
GROUP BY category
ORDER BY feedback_count DESC
`

type GetCustomerFeedbacksByCategoryParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetCustomerFeedbacksByCategoryRow struct {
	Category      string `json:"category"`
	FeedbackCount int64  `json:"feedback_count"`
}

// Thống kê feedback theo category
func (q *Queries) GetCustomerFeedbacksByCategory(ctx context.Context, arg GetCustomerFeedbacksByCategoryParams) ([]GetCustomerFeedbacksByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerFeedbacksByCategory,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomerFeedbacksByCategoryRow
	for rows.Next() {
		var i GetCustomerFeedbacksByCategoryRow
		if err := rows.Scan(&i.Category, &i.FeedbackCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageRatingStats = `-- name: GetMessageRatingStats :one
SELECT
    COUNT(*) AS total_ratings,
    COUNT(CASE WHEN rating = 1 THEN 1 END) AS like_count,
    COUNT(CASE WHEN rating = -1 THEN 1 END) AS dislike_count,
    ROUND(
        (COUNT(CASE WHEN rating = 1 THEN 1 END) * 100.0) / NULLIF(COUNT(*), 0),
        2
    ) AS satisfaction_rate
FROM message_ratings
WHERE
    ? IS NULL 
    OR ? IS NULL 
    OR created_at BETWEEN ? AND ?
`

type GetMessageRatingStatsParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetMessageRatingStatsRow struct {
	TotalRatings     int64   `json:"total_ratings"`
	LikeCount        int64   `json:"like_count"`
	DislikeCount     int64   `json:"dislike_count"`
	SatisfactionRate float64 `json:"satisfaction_rate"`
}

// Thống kê tổng quan đánh giá message ratings
func (q *Queries) GetMessageRatingStats(ctx context.Context, arg GetMessageRatingStatsParams) (GetMessageRatingStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getMessageRatingStats,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
	)
	var i GetMessageRatingStatsRow
	err := row.Scan(
		&i.TotalRatings,
		&i.LikeCount,
		&i.DislikeCount,
		&i.SatisfactionRate,
	)
	return i, err
}

const getMessageRatingsBySession = `-- name: GetMessageRatingsBySession :many
SELECT 
    id,
    event_id,
    session_id,
    user_id,
    rating,
    user_prompt,
    agent_response,
    created_at
FROM message_ratings
WHERE
    (? IS NULL OR session_id = ?)
    AND (? IS NULL OR user_id = ?)
    AND (? IS NULL OR rating = ?)
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR created_at BETWEEN ? AND ?
    )
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetMessageRatingsBySessionParams struct {
	SessionIDFilter sql.NullString `json:"session_id_filter"`
	UserIDFilter    sql.NullString `json:"user_id_filter"`
	RatingFilter    sql.NullInt16  `json:"rating_filter"`
	StartDate       sql.NullTime   `json:"start_date"`
	EndDate         sql.NullTime   `json:"end_date"`
	Limit           int32          `json:"limit"`
	Offset          int32          `json:"offset"`
}

// Lấy danh sách ratings theo session để xem chi tiết
func (q *Queries) GetMessageRatingsBySession(ctx context.Context, arg GetMessageRatingsBySessionParams) ([]MessageRatings, error) {
	rows, err := q.db.QueryContext(ctx, getMessageRatingsBySession,
		arg.SessionIDFilter,
		arg.SessionIDFilter,
		arg.UserIDFilter,
		arg.UserIDFilter,
		arg.RatingFilter,
		arg.RatingFilter,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageRatings
	for rows.Next() {
		var i MessageRatings
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.SessionID,
			&i.UserID,
			&i.Rating,
			&i.UserPrompt,
			&i.AgentResponse,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageRatingsTimeSeries = `-- name: GetMessageRatingsTimeSeries :many
SELECT
    DATE(created_at) AS report_date,
    COUNT(*) AS total_ratings,
    COUNT(CASE WHEN rating = 1 THEN 1 END) AS like_count,
    COUNT(CASE WHEN rating = -1 THEN 1 END) AS dislike_count,
    ROUND(
        (COUNT(CASE WHEN rating = 1 THEN 1 END) * 100.0) / NULLIF(COUNT(*), 0),
        2
    ) AS satisfaction_rate
FROM message_ratings
WHERE
    ? IS NULL 
    OR ? IS NULL 
    OR created_at BETWEEN ? AND ?
GROUP BY report_date
ORDER BY report_date ASC
`

type GetMessageRatingsTimeSeriesParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetMessageRatingsTimeSeriesRow struct {
	ReportDate       time.Time `json:"report_date"`
	TotalRatings     int64     `json:"total_ratings"`
	LikeCount        int64     `json:"like_count"`
	DislikeCount     int64     `json:"dislike_count"`
	SatisfactionRate float64   `json:"satisfaction_rate"`
}

// Thống kê theo thời gian (theo ngày)
func (q *Queries) GetMessageRatingsTimeSeries(ctx context.Context, arg GetMessageRatingsTimeSeriesParams) ([]GetMessageRatingsTimeSeriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessageRatingsTimeSeries,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessageRatingsTimeSeriesRow
	for rows.Next() {
		var i GetMessageRatingsTimeSeriesRow
		if err := rows.Scan(
			&i.ReportDate,
			&i.TotalRatings,
			&i.LikeCount,
			&i.DislikeCount,
			&i.SatisfactionRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomerFeedbacks = `-- name: ListCustomerFeedbacks :many
SELECT id, user_id, email, phone, category, content, created_at, updated_at FROM customer_feedback
WHERE
    (? IS NULL OR category = ?)
    AND (? IS NULL OR user_id = ?)
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR created_at BETWEEN ? AND ?
    )
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListCustomerFeedbacksParams struct {
	CategoryFilter sql.NullString `json:"category_filter"`
	UserIDFilter   sql.NullString `json:"user_id_filter"`
	StartDate      sql.NullTime   `json:"start_date"`
	EndDate        sql.NullTime   `json:"end_date"`
	Limit          int32          `json:"limit"`
	Offset         int32          `json:"offset"`
}

// Lấy danh sách feedback cho Admin xem
func (q *Queries) ListCustomerFeedbacks(ctx context.Context, arg ListCustomerFeedbacksParams) ([]CustomerFeedback, error) {
	rows, err := q.db.QueryContext(ctx, listCustomerFeedbacks,
		arg.CategoryFilter,
		arg.CategoryFilter,
		arg.UserIDFilter,
		arg.UserIDFilter,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomerFeedback
	for rows.Next() {
		var i CustomerFeedback
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.Phone,
			&i.Category,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
