// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: discount.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getPlatformVoucherPerformance = `-- name: GetPlatformVoucherPerformance :one
SELECT
    COUNT(vuh.id) AS total_usage_count,
    COALESCE(SUM(vuh.discount_amount), 0.00) AS total_discount_value
FROM voucher_usage_history vuh
JOIN vouchers v ON vuh.voucher_id = v.id
WHERE
    v.owner_type = 'PLATFORM'
    AND (vuh.used_at BETWEEN ? AND ?)
`

type GetPlatformVoucherPerformanceParams struct {
	FromUsedAt time.Time `json:"from_used_at"`
	ToUsedAt   time.Time `json:"to_used_at"`
}

type GetPlatformVoucherPerformanceRow struct {
	TotalUsageCount    int64       `json:"total_usage_count"`
	TotalDiscountValue interface{} `json:"total_discount_value"`
}

// TácG: Thống kê hiệu suất voucher Sàn (API: GET /platform/vouchers/performance/platform)
func (q *Queries) GetPlatformVoucherPerformance(ctx context.Context, arg GetPlatformVoucherPerformanceParams) (GetPlatformVoucherPerformanceRow, error) {
	row := q.db.QueryRowContext(ctx, getPlatformVoucherPerformance, arg.FromUsedAt, arg.ToUsedAt)
	var i GetPlatformVoucherPerformanceRow
	err := row.Scan(&i.TotalUsageCount, &i.TotalDiscountValue)
	return i, err
}

const getVoucherUsageHistory = `-- name: GetVoucherUsageHistory :many
SELECT id, voucher_id, user_id, discount_amount, used_at FROM voucher_usage_history
WHERE
    voucher_id = ?
ORDER BY used_at DESC
LIMIT ? OFFSET ?
`

type GetVoucherUsageHistoryParams struct {
	VoucherID string `json:"voucher_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

// Tác dụng: Lấy lịch sử sử dụng của 1 voucher (API: GET /shop/vouchers/{id}/detail)
func (q *Queries) GetVoucherUsageHistory(ctx context.Context, arg GetVoucherUsageHistoryParams) ([]VoucherUsageHistory, error) {
	rows, err := q.db.QueryContext(ctx, getVoucherUsageHistory, arg.VoucherID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VoucherUsageHistory
	for rows.Next() {
		var i VoucherUsageHistory
		if err := rows.Scan(
			&i.ID,
			&i.VoucherID,
			&i.UserID,
			&i.DiscountAmount,
			&i.UsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoucherUsagePerformanceByOwner = `-- name: GetVoucherUsagePerformanceByOwner :one
SELECT
    COUNT(vuh.id) AS total_usage_count,
    COALESCE(SUM(vuh.discount_amount), 0.00) AS total_discount_value
FROM voucher_usage_history vuh
JOIN vouchers v ON vuh.voucher_id = v.id
WHERE
    v.owner_id = ? AND v.owner_type = 'SHOP'
    AND (vuh.used_at BETWEEN ? AND ?)
`

type GetVoucherUsagePerformanceByOwnerParams struct {
	OwnerID    string    `json:"owner_id"`
	FromUsedAt time.Time `json:"from_used_at"`
	ToUsedAt   time.Time `json:"to_used_at"`
}

type GetVoucherUsagePerformanceByOwnerRow struct {
	TotalUsageCount    int64       `json:"total_usage_count"`
	TotalDiscountValue interface{} `json:"total_discount_value"`
}

// Tác dụng: Thống kê hiệu suất voucher của Shop (API: GET /shop/vouchers/performance)
// Lưu ý: CSDL voucher_usage_history thiếu shop_order_id, nên chúng ta join bằng voucher_id
func (q *Queries) GetVoucherUsagePerformanceByOwner(ctx context.Context, arg GetVoucherUsagePerformanceByOwnerParams) (GetVoucherUsagePerformanceByOwnerRow, error) {
	row := q.db.QueryRowContext(ctx, getVoucherUsagePerformanceByOwner, arg.OwnerID, arg.FromUsedAt, arg.ToUsedAt)
	var i GetVoucherUsagePerformanceByOwnerRow
	err := row.Scan(&i.TotalUsageCount, &i.TotalDiscountValue)
	return i, err
}

const listPlatformVouchers = `-- name: ListPlatformVouchers :many

SELECT id, name, voucher_code, owner_type, owner_id, discount_type, discount_value, max_discount_amount, applies_to_type, min_purchase_amount, audience_type, start_date, end_date, total_quantity, used_quantity, max_usage_per_user, is_active, created_at, updated_at FROM vouchers
WHERE
    (? IS NULL OR owner_type = ?)
    AND (? IS NULL OR is_active = ?)
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPlatformVouchersParams struct {
	OwnerTypeFilter NullVouchersOwnerType `json:"owner_type_filter"`
	IsActiveFilter  sql.NullBool          `json:"is_active_filter"`
	Limit           int32                 `json:"limit"`
	Offset          int32                 `json:"offset"`
}

// =================================================================
// II. API CHO SÀN (Platform-facing APIs)
// =================================================================
// Tác dụng: Lấy tất cả voucher trên Sàn (API: GET /platform/vouchers)
// ĐÃ SỬA: Bỏ các cast '::text'
func (q *Queries) ListPlatformVouchers(ctx context.Context, arg ListPlatformVouchersParams) ([]Vouchers, error) {
	rows, err := q.db.QueryContext(ctx, listPlatformVouchers,
		arg.OwnerTypeFilter,
		arg.OwnerTypeFilter,
		arg.IsActiveFilter,
		arg.IsActiveFilter,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vouchers
	for rows.Next() {
		var i Vouchers
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.VoucherCode,
			&i.OwnerType,
			&i.OwnerID,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MaxDiscountAmount,
			&i.AppliesToType,
			&i.MinPurchaseAmount,
			&i.AudienceType,
			&i.StartDate,
			&i.EndDate,
			&i.TotalQuantity,
			&i.UsedQuantity,
			&i.MaxUsagePerUser,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVouchersByOwner = `-- name: ListVouchersByOwner :many

SELECT id, name, voucher_code, owner_type, owner_id, discount_type, discount_value, max_discount_amount, applies_to_type, min_purchase_amount, audience_type, start_date, end_date, total_quantity, used_quantity, max_usage_per_user, is_active, created_at, updated_at FROM vouchers
WHERE
    owner_id = ? AND owner_type = 'SHOP'
    AND (? IS NULL OR is_active = ?)
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListVouchersByOwnerParams struct {
	OwnerID        string       `json:"owner_id"`
	IsActiveFilter sql.NullBool `json:"is_active_filter"`
	Limit          int32        `json:"limit"`
	Offset         int32        `json:"offset"`
}

// =================================================================
// I. API CHO SHOP (Shop-facing APIs)
// =================================================================
// Tác dụng: Lấy danh sách voucher Shop đã tạo (API: GET /shop/vouchers)
func (q *Queries) ListVouchersByOwner(ctx context.Context, arg ListVouchersByOwnerParams) ([]Vouchers, error) {
	rows, err := q.db.QueryContext(ctx, listVouchersByOwner,
		arg.OwnerID,
		arg.IsActiveFilter,
		arg.IsActiveFilter,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vouchers
	for rows.Next() {
		var i Vouchers
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.VoucherCode,
			&i.OwnerType,
			&i.OwnerID,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MaxDiscountAmount,
			&i.AppliesToType,
			&i.MinPurchaseAmount,
			&i.AudienceType,
			&i.StartDate,
			&i.EndDate,
			&i.TotalQuantity,
			&i.UsedQuantity,
			&i.MaxUsagePerUser,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
