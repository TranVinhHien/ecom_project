// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package db

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, order_code, user_id, grand_total, subtotal, total_shipping_fee, total_discount, site_order_voucher_code, site_order_voucher_discount, site_shipping_voucher_code, site_shipping_voucher_discount, shipping_address_snapshot, payment_method_snapshot, note, created_at, updated_at FROM orders
WHERE id = ?
`

// Tác dụng: Lấy thông tin đơn hàng TỔNG (API: GET /platform/orders/{id}/detail)
func (q *Queries) GetOrderByID(ctx context.Context, id string) (Orders, error) {
	row := q.db.QueryRowContext(ctx, getOrderByID, id)
	var i Orders
	err := row.Scan(
		&i.ID,
		&i.OrderCode,
		&i.UserID,
		&i.GrandTotal,
		&i.Subtotal,
		&i.TotalShippingFee,
		&i.TotalDiscount,
		&i.SiteOrderVoucherCode,
		&i.SiteOrderVoucherDiscount,
		&i.SiteShippingVoucherCode,
		&i.SiteShippingVoucherDiscount,
		&i.ShippingAddressSnapshot,
		&i.PaymentMethodSnapshot,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderIDsFromShopOrders = `-- name: GetOrderIDsFromShopOrders :many
SELECT DISTINCT order_id FROM shop_orders
WHERE id IN (/*SLICE:shop_order_ids*/?)
`

// Tác dụng: Lấy danh sách ID đơn hàng TỔNG (Dùng nội bộ để truy vấn CSDL khác)
// ĐÃ SỬA: Sửa 'ANY(sqlc.slice())' thành 'IN (sqlc.slice())'
func (q *Queries) GetOrderIDsFromShopOrders(ctx context.Context, shopOrderIds []string) ([]string, error) {
	query := getOrderIDsFromShopOrders
	var queryParams []interface{}
	if len(shopOrderIds) > 0 {
		for _, v := range shopOrderIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:shop_order_ids*/?", strings.Repeat(",?", len(shopOrderIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:shop_order_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var order_id string
		if err := rows.Scan(&order_id); err != nil {
			return nil, err
		}
		items = append(items, order_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByShopOrderID = `-- name: GetOrderItemsByShopOrderID :many
SELECT id, shop_order_id, product_id, sku_id, quantity, original_unit_price, final_unit_price, total_price, promotions_snapshot, product_name_snapshot, product_image_snapshot, sku_attributes_snapshot FROM order_items
WHERE shop_order_id = ?
`

// Tác dụng: Lấy các sản phẩm của 1 đơn hàng Shop (API: GET /shop/orders/{id}/enriched)
func (q *Queries) GetOrderItemsByShopOrderID(ctx context.Context, shopOrderID string) ([]OrderItems, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItemsByShopOrderID, shopOrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItems
	for rows.Next() {
		var i OrderItems
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderID,
			&i.ProductID,
			&i.SkuID,
			&i.Quantity,
			&i.OriginalUnitPrice,
			&i.FinalUnitPrice,
			&i.TotalPrice,
			&i.PromotionsSnapshot,
			&i.ProductNameSnapshot,
			&i.ProductImageSnapshot,
			&i.SkuAttributesSnapshot,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformGMVTimeSeries = `-- name: GetPlatformGMVTimeSeries :many
SELECT
    DATE(completed_at) AS report_date,
    COALESCE(SUM(subtotal), 0.00) AS gmv
FROM shop_orders
WHERE
        ? IS NULL 
        OR ? IS NULL 
        OR completed_at BETWEEN ? AND ?
    
GROUP BY report_date
ORDER BY report_date ASC
`

type GetPlatformGMVTimeSeriesParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetPlatformGMVTimeSeriesRow struct {
	ReportDate time.Time   `json:"report_date"`
	Gmv        interface{} `json:"gmv"`
}

func (q *Queries) GetPlatformGMVTimeSeries(ctx context.Context, arg GetPlatformGMVTimeSeriesParams) ([]GetPlatformGMVTimeSeriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlatformGMVTimeSeries,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlatformGMVTimeSeriesRow
	for rows.Next() {
		var i GetPlatformGMVTimeSeriesRow
		if err := rows.Scan(&i.ReportDate, &i.Gmv); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformOrderOverview = `-- name: GetPlatformOrderOverview :one

SELECT
    COUNT(*) AS total_orders,
    COALESCE(SUM(subtotal), 0.00) AS total_gmv,
    COUNT(DISTINCT shop_id) AS total_shops
FROM shop_orders
WHERE
    status = 'COMPLETED'
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR completed_at BETWEEN ? AND ?
    )
`

type GetPlatformOrderOverviewParams struct {
	FromCompletedAt sql.NullTime `json:"from_completed_at"`
	ToCompletedAt   sql.NullTime `json:"to_completed_at"`
}

type GetPlatformOrderOverviewRow struct {
	TotalOrders int64       `json:"total_orders"`
	TotalGmv    interface{} `json:"total_gmv"`
	TotalShops  int64       `json:"total_shops"`
}

// =================================================================
// II. API CHO SÀN (Platform-facing APIs)
// =================================================================
// Tác dụng: Lấy tổng quan GMV và Đơn hàng toàn Sàn (API: GET /platform/overview)
func (q *Queries) GetPlatformOrderOverview(ctx context.Context, arg GetPlatformOrderOverviewParams) (GetPlatformOrderOverviewRow, error) {
	row := q.db.QueryRowContext(ctx, getPlatformOrderOverview,
		arg.FromCompletedAt,
		arg.ToCompletedAt,
		arg.FromCompletedAt,
		arg.ToCompletedAt,
	)
	var i GetPlatformOrderOverviewRow
	err := row.Scan(&i.TotalOrders, &i.TotalGmv, &i.TotalShops)
	return i, err
}

const getPlatformTopProductsByQuantity = `-- name: GetPlatformTopProductsByQuantity :many
SELECT
    oi.product_id,
    oi.product_name_snapshot,
    COALESCE(SUM(oi.quantity), 0) AS total_quantity
FROM order_items oi
JOIN shop_orders so ON oi.shop_order_id = so.id
WHERE
        ? IS NULL 
        OR ? IS NULL 
        OR so.completed_at BETWEEN ? AND ?
    
GROUP BY oi.product_id, oi.product_name_snapshot
ORDER BY total_quantity DESC
LIMIT ?
`

type GetPlatformTopProductsByQuantityParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
	Limit     int32        `json:"limit"`
}

type GetPlatformTopProductsByQuantityRow struct {
	ProductID           string      `json:"product_id"`
	ProductNameSnapshot string      `json:"product_name_snapshot"`
	TotalQuantity       interface{} `json:"total_quantity"`
}

// Tác dụng: Xếp hạng sản phẩm hot nhất toàn Sàn (API: GET /platform/ranking/products)
func (q *Queries) GetPlatformTopProductsByQuantity(ctx context.Context, arg GetPlatformTopProductsByQuantityParams) ([]GetPlatformTopProductsByQuantityRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlatformTopProductsByQuantity,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlatformTopProductsByQuantityRow
	for rows.Next() {
		var i GetPlatformTopProductsByQuantityRow
		if err := rows.Scan(&i.ProductID, &i.ProductNameSnapshot, &i.TotalQuantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformTopShopsByGMV = `-- name: GetPlatformTopShopsByGMV :many
SELECT
    shop_id,
    COALESCE(SUM(subtotal), 0.00) AS total_gmv,
    COUNT(*) AS total_orders
FROM shop_orders
WHERE
        ? IS NULL 
        OR ? IS NULL 
        OR completed_at BETWEEN ? AND ?
    
GROUP BY shop_id
ORDER BY total_gmv DESC
LIMIT ?
`

type GetPlatformTopShopsByGMVParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
	Limit     int32        `json:"limit"`
}

type GetPlatformTopShopsByGMVRow struct {
	ShopID      string      `json:"shop_id"`
	TotalGmv    interface{} `json:"total_gmv"`
	TotalOrders int64       `json:"total_orders"`
}

// Tác dụng: Xếp hạng Shop theo Doanh thu GMV (API: GET /platform/ranking/shops)
func (q *Queries) GetPlatformTopShopsByGMV(ctx context.Context, arg GetPlatformTopShopsByGMVParams) ([]GetPlatformTopShopsByGMVRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlatformTopShopsByGMV,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlatformTopShopsByGMVRow
	for rows.Next() {
		var i GetPlatformTopShopsByGMVRow
		if err := rows.Scan(&i.ShopID, &i.TotalGmv, &i.TotalOrders); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformTopUsersBySpend = `-- name: GetPlatformTopUsersBySpend :many
SELECT
    user_id,
    COALESCE(SUM(grand_total), 0.00) AS total_spent,
    COUNT(*) AS total_orders
FROM orders
WHERE
    ? IS NULL 
    OR ? IS NULL 
    OR created_at BETWEEN ? AND ?
GROUP BY user_id
ORDER BY total_spent DESC
LIMIT ?
`

type GetPlatformTopUsersBySpendParams struct {
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
	Limit     int32        `json:"limit"`
}

type GetPlatformTopUsersBySpendRow struct {
	UserID      string      `json:"user_id"`
	TotalSpent  interface{} `json:"total_spent"`
	TotalOrders int64       `json:"total_orders"`
}

// Tác dụng: Xếp hạng khách hàng chi tiêu nhiều nhất (API: GET /platform/ranking/users)
func (q *Queries) GetPlatformTopUsersBySpend(ctx context.Context, arg GetPlatformTopUsersBySpendParams) ([]GetPlatformTopUsersBySpendRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlatformTopUsersBySpend,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlatformTopUsersBySpendRow
	for rows.Next() {
		var i GetPlatformTopUsersBySpendRow
		if err := rows.Scan(&i.UserID, &i.TotalSpent, &i.TotalOrders); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShopOrderByID = `-- name: GetShopOrderByID :one
SELECT id, shop_order_code, order_id, shop_id, status, subtotal, total_discount, total_amount, shop_voucher_code, shop_voucher_discount, shipping_fee, shipping_method, tracking_code, cancellation_reason, created_at, updated_at, paid_at, processing_at, shipped_at, completed_at, cancelled_at FROM shop_orders
WHERE id = ? AND shop_id = ?
`

type GetShopOrderByIDParams struct {
	ID     string `json:"id"`
	ShopID string `json:"shop_id"`
}

// Tác dụng: Lấy chi tiết 1 đơn hàng của Shop (API: GET /shop/orders/{id}/enriched)
func (q *Queries) GetShopOrderByID(ctx context.Context, arg GetShopOrderByIDParams) (ShopOrders, error) {
	row := q.db.QueryRowContext(ctx, getShopOrderByID, arg.ID, arg.ShopID)
	var i ShopOrders
	err := row.Scan(
		&i.ID,
		&i.ShopOrderCode,
		&i.OrderID,
		&i.ShopID,
		&i.Status,
		&i.Subtotal,
		&i.TotalDiscount,
		&i.TotalAmount,
		&i.ShopVoucherCode,
		&i.ShopVoucherDiscount,
		&i.ShippingFee,
		&i.ShippingMethod,
		&i.TrackingCode,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaidAt,
		&i.ProcessingAt,
		&i.ShippedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const getShopOrderIDs = `-- name: GetShopOrderIDs :many
SELECT id FROM shop_orders
WHERE shop_id = ?
`

// Tác dụng: Lấy danh sách ID đơn hàng của Shop (Dùng nội bộ để truy vấn CSDL khác)
func (q *Queries) GetShopOrderIDs(ctx context.Context, shopID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getShopOrderIDs, shopID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShopOrderOverview = `-- name: GetShopOrderOverview :one

SELECT
    COUNT(*) AS total_orders,
    COALESCE(SUM(subtotal), 0.00) AS total_gmv,
    COUNT(CASE WHEN status = 'PROCESSING' THEN 1 END) AS processing_orders
FROM shop_orders
WHERE
    shop_id = ?
    AND status NOT IN ('CANCELLED', 'AWAITING_PAYMENT')
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR created_at BETWEEN ? AND ?
    )
`

type GetShopOrderOverviewParams struct {
	ShopID    string       `json:"shop_id"`
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
}

type GetShopOrderOverviewRow struct {
	TotalOrders      int64       `json:"total_orders"`
	TotalGmv         interface{} `json:"total_gmv"`
	ProcessingOrders int64       `json:"processing_orders"`
}

// =================================================================
// I. API CHO SHOP (Shop-facing APIs)
// =================================================================
// Tác dụng: Lấy chỉ số tổng quan cho Dashboard của Shop (API: GET /shop/overview)
func (q *Queries) GetShopOrderOverview(ctx context.Context, arg GetShopOrderOverviewParams) (GetShopOrderOverviewRow, error) {
	row := q.db.QueryRowContext(ctx, getShopOrderOverview,
		arg.ShopID,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
	)
	var i GetShopOrderOverviewRow
	err := row.Scan(&i.TotalOrders, &i.TotalGmv, &i.ProcessingOrders)
	return i, err
}

const getShopOrdersByOrderID = `-- name: GetShopOrdersByOrderID :many
SELECT id, shop_order_code, order_id, shop_id, status, subtotal, total_discount, total_amount, shop_voucher_code, shop_voucher_discount, shipping_fee, shipping_method, tracking_code, cancellation_reason, created_at, updated_at, paid_at, processing_at, shipped_at, completed_at, cancelled_at FROM shop_orders
WHERE order_id = ?
`

// Tác dụng: Lấy các đơn hàng SHOP con của đơn hàng TỔNG (API: GET /platform/orders/{id}/detail)
func (q *Queries) GetShopOrdersByOrderID(ctx context.Context, orderID string) ([]ShopOrders, error) {
	rows, err := q.db.QueryContext(ctx, getShopOrdersByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShopOrders
	for rows.Next() {
		var i ShopOrders
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderCode,
			&i.OrderID,
			&i.ShopID,
			&i.Status,
			&i.Subtotal,
			&i.TotalDiscount,
			&i.TotalAmount,
			&i.ShopVoucherCode,
			&i.ShopVoucherDiscount,
			&i.ShippingFee,
			&i.ShippingMethod,
			&i.TrackingCode,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaidAt,
			&i.ProcessingAt,
			&i.ShippedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShopRevenueTimeSeries = `-- name: GetShopRevenueTimeSeries :many
SELECT
    DATE(completed_at) AS report_date,
    COALESCE(SUM(subtotal), 0.00) AS gmv
FROM shop_orders
WHERE
    shop_id = ?
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR completed_at BETWEEN ? AND ?
    )
GROUP BY report_date
ORDER BY report_date ASC
`

type GetShopRevenueTimeSeriesParams struct {
	ShopID          string       `json:"shop_id"`
	FromCompletedAt sql.NullTime `json:"from_completed_at"`
	ToCompletedAt   sql.NullTime `json:"to_completed_at"`
}

type GetShopRevenueTimeSeriesRow struct {
	ReportDate time.Time   `json:"report_date"`
	Gmv        interface{} `json:"gmv"`
}

// Tác dụng: Lấy dữ liệu doanh thu GMV theo ngày để vẽ biểu đồ (API: GET /shop/revenue/timeseries)
func (q *Queries) GetShopRevenueTimeSeries(ctx context.Context, arg GetShopRevenueTimeSeriesParams) ([]GetShopRevenueTimeSeriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getShopRevenueTimeSeries,
		arg.ShopID,
		arg.FromCompletedAt,
		arg.ToCompletedAt,
		arg.FromCompletedAt,
		arg.ToCompletedAt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShopRevenueTimeSeriesRow
	for rows.Next() {
		var i GetShopRevenueTimeSeriesRow
		if err := rows.Scan(&i.ReportDate, &i.Gmv); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShopTopProductsByQuantity = `-- name: GetShopTopProductsByQuantity :many
SELECT
    oi.product_id,
    oi.sku_id,
    oi.product_name_snapshot,
    oi.sku_attributes_snapshot,
    COALESCE(SUM(oi.quantity), 0) AS total_quantity
FROM order_items oi
JOIN shop_orders so ON oi.shop_order_id = so.id
WHERE
    so.shop_id = ?
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR so.completed_at BETWEEN ? AND ?
    )
GROUP BY oi.product_id, oi.sku_id, oi.product_name_snapshot, oi.sku_attributes_snapshot
ORDER BY total_quantity DESC
LIMIT ?
`

type GetShopTopProductsByQuantityParams struct {
	ShopID    string       `json:"shop_id"`
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
	Limit     int32        `json:"limit"`
}

type GetShopTopProductsByQuantityRow struct {
	ProductID             string         `json:"product_id"`
	SkuID                 string         `json:"sku_id"`
	ProductNameSnapshot   string         `json:"product_name_snapshot"`
	SkuAttributesSnapshot sql.NullString `json:"sku_attributes_snapshot"`
	TotalQuantity         interface{}    `json:"total_quantity"`
}

// Tác dụng: Xếp hạng sản phẩm theo Số lượng bán (API: GET /shop/ranking/products/by-quantity)
func (q *Queries) GetShopTopProductsByQuantity(ctx context.Context, arg GetShopTopProductsByQuantityParams) ([]GetShopTopProductsByQuantityRow, error) {
	rows, err := q.db.QueryContext(ctx, getShopTopProductsByQuantity,
		arg.ShopID,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShopTopProductsByQuantityRow
	for rows.Next() {
		var i GetShopTopProductsByQuantityRow
		if err := rows.Scan(
			&i.ProductID,
			&i.SkuID,
			&i.ProductNameSnapshot,
			&i.SkuAttributesSnapshot,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShopTopProductsByRevenue = `-- name: GetShopTopProductsByRevenue :many
SELECT
    oi.product_id,
    oi.sku_id,
    oi.product_name_snapshot,
    oi.sku_attributes_snapshot,
    COALESCE(SUM(oi.total_price), 0.00) AS total_revenue
FROM order_items oi
JOIN shop_orders so ON oi.shop_order_id = so.id
WHERE
    so.shop_id = ?
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR so.completed_at BETWEEN ? AND ?
    )
GROUP BY oi.product_id, oi.sku_id, oi.product_name_snapshot, oi.sku_attributes_snapshot
ORDER BY total_revenue DESC
LIMIT ?
`

type GetShopTopProductsByRevenueParams struct {
	ShopID    string       `json:"shop_id"`
	StartDate sql.NullTime `json:"start_date"`
	EndDate   sql.NullTime `json:"end_date"`
	Limit     int32        `json:"limit"`
}

type GetShopTopProductsByRevenueRow struct {
	ProductID             string         `json:"product_id"`
	SkuID                 string         `json:"sku_id"`
	ProductNameSnapshot   string         `json:"product_name_snapshot"`
	SkuAttributesSnapshot sql.NullString `json:"sku_attributes_snapshot"`
	TotalRevenue          interface{}    `json:"total_revenue"`
}

// Tác dụng: Xếp hạng sản phẩm theo Doanh thu (API: GET /shop/ranking/products/by-revenue)
func (q *Queries) GetShopTopProductsByRevenue(ctx context.Context, arg GetShopTopProductsByRevenueParams) ([]GetShopTopProductsByRevenueRow, error) {
	rows, err := q.db.QueryContext(ctx, getShopTopProductsByRevenue,
		arg.ShopID,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShopTopProductsByRevenueRow
	for rows.Next() {
		var i GetShopTopProductsByRevenueRow
		if err := rows.Scan(
			&i.ProductID,
			&i.SkuID,
			&i.ProductNameSnapshot,
			&i.SkuAttributesSnapshot,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlatformOrders = `-- name: ListPlatformOrders :many
SELECT id, shop_order_code, order_id, shop_id, status, subtotal, total_discount, total_amount, shop_voucher_code, shop_voucher_discount, shipping_fee, shipping_method, tracking_code, cancellation_reason, created_at, updated_at, paid_at, processing_at, shipped_at, completed_at, cancelled_at FROM shop_orders
WHERE
    (? IS NULL OR shop_id = ?)
    AND (? IS NULL OR status = ?)
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR created_at BETWEEN ? AND ?
    )
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPlatformOrdersParams struct {
	ShopIDFilter sql.NullString       `json:"shop_id_filter"`
	StatusFilter NullShopOrdersStatus `json:"status_filter"`
	StartDate    sql.NullTime         `json:"start_date"`
	EndDate      sql.NullTime         `json:"end_date"`
	Limit        int32                `json:"limit"`
	Offset       int32                `json:"offset"`
}

// Tác dụng: Lấy danh sách TẤT CẢ đơn hàng trên Sàn (API: GET /platform/orders)
func (q *Queries) ListPlatformOrders(ctx context.Context, arg ListPlatformOrdersParams) ([]ShopOrders, error) {
	rows, err := q.db.QueryContext(ctx, listPlatformOrders,
		arg.ShopIDFilter,
		arg.ShopIDFilter,
		arg.StatusFilter,
		arg.StatusFilter,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShopOrders
	for rows.Next() {
		var i ShopOrders
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderCode,
			&i.OrderID,
			&i.ShopID,
			&i.Status,
			&i.Subtotal,
			&i.TotalDiscount,
			&i.TotalAmount,
			&i.ShopVoucherCode,
			&i.ShopVoucherDiscount,
			&i.ShippingFee,
			&i.ShippingMethod,
			&i.TrackingCode,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaidAt,
			&i.ProcessingAt,
			&i.ShippedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShopOrders = `-- name: ListShopOrders :many
SELECT id, shop_order_code, order_id, shop_id, status, subtotal, total_discount, total_amount, shop_voucher_code, shop_voucher_discount, shipping_fee, shipping_method, tracking_code, cancellation_reason, created_at, updated_at, paid_at, processing_at, shipped_at, completed_at, cancelled_at FROM shop_orders
WHERE
    shop_id = ?
    AND (? IS NULL OR status = ?)
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR created_at BETWEEN ? AND ?
    )
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListShopOrdersParams struct {
	ShopID       string               `json:"shop_id"`
	StatusFilter NullShopOrdersStatus `json:"status_filter"`
	StartDate    sql.NullTime         `json:"start_date"`
	EndDate      sql.NullTime         `json:"end_date"`
	Limit        int32                `json:"limit"`
	Offset       int32                `json:"offset"`
}

// Tác dụng: Lấy danh sách đơn hàng (phân trang) cho Shop (API: GET /shop/orders)
func (q *Queries) ListShopOrders(ctx context.Context, arg ListShopOrdersParams) ([]ShopOrders, error) {
	rows, err := q.db.QueryContext(ctx, listShopOrders,
		arg.ShopID,
		arg.StatusFilter,
		arg.StatusFilter,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShopOrders
	for rows.Next() {
		var i ShopOrders
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderCode,
			&i.OrderID,
			&i.ShopID,
			&i.Status,
			&i.Subtotal,
			&i.TotalDiscount,
			&i.TotalAmount,
			&i.ShopVoucherCode,
			&i.ShopVoucherDiscount,
			&i.ShippingFee,
			&i.ShippingMethod,
			&i.TrackingCode,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaidAt,
			&i.ProcessingAt,
			&i.ShippedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
