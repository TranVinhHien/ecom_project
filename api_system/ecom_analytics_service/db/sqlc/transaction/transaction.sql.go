// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const getLedgerByOwnerID = `-- name: GetLedgerByOwnerID :one

SELECT id, owner_id, owner_type, balance, pending_balance, created_at, updated_at FROM account_ledgers
WHERE owner_id = ? AND owner_type = 'SHOP'
`

// =================================================================
// I. API CHO SHOP (Shop-facing APIs)
// =================================================================
// Tác dụng: Lấy thông tin ví của Shop (API: GET /shop/overview, /shop/wallet/summary)
func (q *Queries) GetLedgerByOwnerID(ctx context.Context, ownerID string) (AccountLedgers, error) {
	row := q.db.QueryRowContext(ctx, getLedgerByOwnerID, ownerID)
	var i AccountLedgers
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.OwnerType,
		&i.Balance,
		&i.PendingBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlatformCostSummary = `-- name: GetPlatformCostSummary :one
SELECT
    COALESCE(SUM(site_order_voucher_discount_amount), 0.00) AS total_order_voucher_cost,
    COALESCE(SUM(site_promotion_discount_amount), 0.00) AS total_promotion_cost,
    COALESCE(SUM(site_shipping_discount_amount), 0.00) AS total_shipping_discount_cost,
    COALESCE(SUM(total_site_funded_product_discount), 0.00) AS total_product_subsidy_cost
FROM order_platform_costs
WHERE created_at BETWEEN ? AND ?
`

type GetPlatformCostSummaryParams struct {
	FromCreatedAt time.Time `json:"from_created_at"`
	ToCreatedAt   time.Time `json:"to_created_at"`
}

type GetPlatformCostSummaryRow struct {
	TotalOrderVoucherCost     interface{} `json:"total_order_voucher_cost"`
	TotalPromotionCost        interface{} `json:"total_promotion_cost"`
	TotalShippingDiscountCost interface{} `json:"total_shipping_discount_cost"`
	TotalProductSubsidyCost   interface{} `json:"total_product_subsidy_cost"`
}

// Tác dụng: Lấy Tổng chi phí Sàn (API: GET /platform/overview)
func (q *Queries) GetPlatformCostSummary(ctx context.Context, arg GetPlatformCostSummaryParams) (GetPlatformCostSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getPlatformCostSummary, arg.FromCreatedAt, arg.ToCreatedAt)
	var i GetPlatformCostSummaryRow
	err := row.Scan(
		&i.TotalOrderVoucherCost,
		&i.TotalPromotionCost,
		&i.TotalShippingDiscountCost,
		&i.TotalProductSubsidyCost,
	)
	return i, err
}

const getPlatformCostTimeSeries = `-- name: GetPlatformCostTimeSeries :many
SELECT
    DATE(created_at) AS report_date,
    COALESCE(SUM(
        site_order_voucher_discount_amount +
        site_promotion_discount_amount +
        site_shipping_discount_amount +
        total_site_funded_product_discount
    ), 0.00) AS total_cost
FROM order_platform_costs
WHERE created_at BETWEEN ? AND ?
GROUP BY report_date
ORDER BY report_date ASC
`

type GetPlatformCostTimeSeriesParams struct {
	FromCreatedAt time.Time `json:"from_created_at"`
	ToCreatedAt   time.Time `json:"to_created_at"`
}

type GetPlatformCostTimeSeriesRow struct {
	ReportDate time.Time   `json:"report_date"`
	TotalCost  interface{} `json:"total_cost"`
}

// Tác dụng: Vẽ biểu đồ Chi phí Sàn (API: GET /platform/finance/revenue-timeseries)
func (q *Queries) GetPlatformCostTimeSeries(ctx context.Context, arg GetPlatformCostTimeSeriesParams) ([]GetPlatformCostTimeSeriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlatformCostTimeSeries, arg.FromCreatedAt, arg.ToCreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlatformCostTimeSeriesRow
	for rows.Next() {
		var i GetPlatformCostTimeSeriesRow
		if err := rows.Scan(&i.ReportDate, &i.TotalCost); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformRevenueSummary = `-- name: GetPlatformRevenueSummary :one

SELECT
    COALESCE(SUM(commission_fee), 0.00) AS total_commission,
    COALESCE(SUM(shipping_fee), 0.00) AS total_shipping_revenue
FROM shop_order_settlements
WHERE
    status = 'SETTLED'
    AND settled_at BETWEEN ? AND ?
`

type GetPlatformRevenueSummaryParams struct {
	FromSettledAt sql.NullTime `json:"from_settled_at"`
	ToSettledAt   sql.NullTime `json:"to_settled_at"`
}

type GetPlatformRevenueSummaryRow struct {
	TotalCommission      interface{} `json:"total_commission"`
	TotalShippingRevenue interface{} `json:"total_shipping_revenue"`
}

// =================================================================
// II. API CHO SÀN (Platform-facing APIs)
// =================================================================
// Tác dụng: Lấy Doanh thu & Chi phí của Sàn (API: GET /platform/overview)
func (q *Queries) GetPlatformRevenueSummary(ctx context.Context, arg GetPlatformRevenueSummaryParams) (GetPlatformRevenueSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getPlatformRevenueSummary, arg.FromSettledAt, arg.ToSettledAt)
	var i GetPlatformRevenueSummaryRow
	err := row.Scan(&i.TotalCommission, &i.TotalShippingRevenue)
	return i, err
}

const getPlatformRevenueTimeSeries = `-- name: GetPlatformRevenueTimeSeries :many
SELECT
    DATE(settled_at) AS report_date,
    COALESCE(SUM(commission_fee), 0.00) AS platform_revenue
FROM shop_order_settlements
WHERE
    status = 'SETTLED'
    AND settled_at BETWEEN ? AND ?
GROUP BY report_date
ORDER BY report_date ASC
`

type GetPlatformRevenueTimeSeriesParams struct {
	FromSettledAt sql.NullTime `json:"from_settled_at"`
	ToSettledAt   sql.NullTime `json:"to_settled_at"`
}

type GetPlatformRevenueTimeSeriesRow struct {
	ReportDate      time.Time   `json:"report_date"`
	PlatformRevenue interface{} `json:"platform_revenue"`
}

// Tác dụng: Vẽ biểu đồ Doanh thu Sàn (API: GET /platform/finance/revenue-timeseries)
func (q *Queries) GetPlatformRevenueTimeSeries(ctx context.Context, arg GetPlatformRevenueTimeSeriesParams) ([]GetPlatformRevenueTimeSeriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlatformRevenueTimeSeries, arg.FromSettledAt, arg.ToSettledAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlatformRevenueTimeSeriesRow
	for rows.Next() {
		var i GetPlatformRevenueTimeSeriesRow
		if err := rows.Scan(&i.ReportDate, &i.PlatformRevenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShopSettlementStatsByOrderIDs = `-- name: GetShopSettlementStatsByOrderIDs :one
SELECT
    COALESCE(SUM(CASE WHEN status = 'SETTLED' THEN net_settled_amount END), 0.00) AS total_settled,
    COALESCE(SUM(CASE WHEN status = 'FUNDS_HELD' THEN net_settled_amount END), 0.00) AS total_funds_held
FROM shop_order_settlements
WHERE shop_order_id IN (/*SLICE:shop_order_ids*/?)
`

type GetShopSettlementStatsByOrderIDsRow struct {
	TotalSettled   interface{} `json:"total_settled"`
	TotalFundsHeld interface{} `json:"total_funds_held"`
}

// Tác dụng: Thống kê tổng tiền đối soát của Shop (API: GET /shop/wallet/summary)
// ĐÃ SỬA: Sửa 'ANY(sqlc.slice())' thành 'IN (sqlc.slice())'
func (q *Queries) GetShopSettlementStatsByOrderIDs(ctx context.Context, shopOrderIds []string) (GetShopSettlementStatsByOrderIDsRow, error) {
	query := getShopSettlementStatsByOrderIDs
	var queryParams []interface{}
	if len(shopOrderIds) > 0 {
		for _, v := range shopOrderIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:shop_order_ids*/?", strings.Repeat(",?", len(shopOrderIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:shop_order_ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var i GetShopSettlementStatsByOrderIDsRow
	err := row.Scan(&i.TotalSettled, &i.TotalFundsHeld)
	return i, err
}

const getShopSettlementsByOrderIDs = `-- name: GetShopSettlementsByOrderIDs :many
SELECT id, shop_order_id, order_transaction_id, status, order_subtotal, shop_funded_product_discount, site_funded_product_discount, shop_voucher_discount, shop_shipping_discount, shipping_fee, commission_fee, net_settled_amount, order_completed_at, settled_at FROM shop_order_settlements
WHERE shop_order_id IN (/*SLICE:shop_order_ids*/?)
`

// Tác dụng: Lấy thông tin đối soát của Shop (API: GET /shop/settlements)
// ĐÃ SỬA: Sửa 'ANY(sqlc.slice())' thành 'IN (sqlc.slice())'
func (q *Queries) GetShopSettlementsByOrderIDs(ctx context.Context, shopOrderIds []string) ([]ShopOrderSettlements, error) {
	query := getShopSettlementsByOrderIDs
	var queryParams []interface{}
	if len(shopOrderIds) > 0 {
		for _, v := range shopOrderIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:shop_order_ids*/?", strings.Repeat(",?", len(shopOrderIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:shop_order_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShopOrderSettlements
	for rows.Next() {
		var i ShopOrderSettlements
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderID,
			&i.OrderTransactionID,
			&i.Status,
			&i.OrderSubtotal,
			&i.ShopFundedProductDiscount,
			&i.SiteFundedProductDiscount,
			&i.ShopVoucherDiscount,
			&i.ShopShippingDiscount,
			&i.ShippingFee,
			&i.CommissionFee,
			&i.NetSettledAmount,
			&i.OrderCompletedAt,
			&i.SettledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionStatusesByOrderIDs = `-- name: GetTransactionStatusesByOrderIDs :many
SELECT order_id, status FROM transactions
WHERE order_id IN (/*SLICE:order_ids*/?)
  AND type = 'PAYMENT'
`

type GetTransactionStatusesByOrderIDsRow struct {
	OrderID sql.NullString     `json:"order_id"`
	Status  TransactionsStatus `json:"status"`
}

// Tác dụng: Lấy trạng thái thanh toán cho 1 loạt đơn hàng (Dùng nội bộ)
// ĐÃ SỬA: Sửa 'ANY(sqlc.slice())' thành 'IN (sqlc.slice())'
func (q *Queries) GetTransactionStatusesByOrderIDs(ctx context.Context, orderIds []sql.NullString) ([]GetTransactionStatusesByOrderIDsRow, error) {
	query := getTransactionStatusesByOrderIDs
	var queryParams []interface{}
	if len(orderIds) > 0 {
		for _, v := range orderIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:order_ids*/?", strings.Repeat(",?", len(orderIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:order_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransactionStatusesByOrderIDsRow
	for rows.Next() {
		var i GetTransactionStatusesByOrderIDsRow
		if err := rows.Scan(&i.OrderID, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLedgerEntriesByLedgerID = `-- name: ListLedgerEntriesByLedgerID :many
SELECT id, ledger_id, transaction_id, amount, type, description, created_at FROM ledger_entries
WHERE ledger_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListLedgerEntriesByLedgerIDParams struct {
	LedgerID string `json:"ledger_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

// Tác dụng: Lấy lịch sử giao dịch của 1 ví cụ thể (API: GET /platform/finance/ledgers/{id}/entries)
func (q *Queries) ListLedgerEntriesByLedgerID(ctx context.Context, arg ListLedgerEntriesByLedgerIDParams) ([]LedgerEntries, error) {
	rows, err := q.db.QueryContext(ctx, listLedgerEntriesByLedgerID, arg.LedgerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerEntries
	for rows.Next() {
		var i LedgerEntries
		if err := rows.Scan(
			&i.ID,
			&i.LedgerID,
			&i.TransactionID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLedgerEntriesByOwnerID = `-- name: ListLedgerEntriesByOwnerID :many
SELECT le.id, le.ledger_id, le.transaction_id, le.amount, le.type, le.description, le.created_at
FROM ledger_entries le
JOIN account_ledgers al ON le.ledger_id = al.id
WHERE
    al.owner_id = ? AND al.owner_type = 'SHOP'
ORDER BY le.created_at DESC
LIMIT ? OFFSET ?
`

type ListLedgerEntriesByOwnerIDParams struct {
	OwnerID string `json:"owner_id"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

// Tác dụng: Lấy lịch sử giao dịch ví của Shop (API: GET /shop/wallet/ledger-entries)
func (q *Queries) ListLedgerEntriesByOwnerID(ctx context.Context, arg ListLedgerEntriesByOwnerIDParams) ([]LedgerEntries, error) {
	rows, err := q.db.QueryContext(ctx, listLedgerEntriesByOwnerID, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerEntries
	for rows.Next() {
		var i LedgerEntries
		if err := rows.Scan(
			&i.ID,
			&i.LedgerID,
			&i.TransactionID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlatformLedgers = `-- name: ListPlatformLedgers :many
SELECT id, owner_id, owner_type, balance, pending_balance, created_at, updated_at FROM account_ledgers
WHERE
    (? IS NULL OR owner_type = ?)
LIMIT ? OFFSET ?
`

type ListPlatformLedgersParams struct {
	OwnerTypeFilter NullAccountLedgersOwnerType `json:"owner_type_filter"`
	Limit           int32                       `json:"limit"`
	Offset          int32                       `json:"offset"`
}

// Tác dụng: Lấy tất cả ví trên Sàn (API: GET /platform/finance/ledgers)
// ĐÃ SỬA: Bỏ các cast '::text'
func (q *Queries) ListPlatformLedgers(ctx context.Context, arg ListPlatformLedgersParams) ([]AccountLedgers, error) {
	rows, err := q.db.QueryContext(ctx, listPlatformLedgers,
		arg.OwnerTypeFilter,
		arg.OwnerTypeFilter,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountLedgers
	for rows.Next() {
		var i AccountLedgers
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.OwnerType,
			&i.Balance,
			&i.PendingBalance,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlatformSettlements = `-- name: ListPlatformSettlements :many
SELECT id, shop_order_id, order_transaction_id, status, order_subtotal, shop_funded_product_discount, site_funded_product_discount, shop_voucher_discount, shop_shipping_discount, shipping_fee, commission_fee, net_settled_amount, order_completed_at, settled_at FROM shop_order_settlements
WHERE
    (? IS NULL OR status = ?)
    AND (
        ? IS NULL 
        OR ? IS NULL 
        OR order_completed_at BETWEEN ? AND ?
    )
ORDER BY order_completed_at DESC
LIMIT ? OFFSET ?
`

type ListPlatformSettlementsParams struct {
	StatusFilter NullShopOrderSettlementsStatus `json:"status_filter"`
	StartDate    sql.NullTime                   `json:"start_date"`
	EndDate      sql.NullTime                   `json:"end_date"`
	Limit        int32                          `json:"limit"`
	Offset       int32                          `json:"offset"`
}

// Tác dụng: Lấy tất cả bản ghi đối soát (API: GET /platform/finance/settlements)
// ĐÃ SỬA: Bỏ các cast '::text'
func (q *Queries) ListPlatformSettlements(ctx context.Context, arg ListPlatformSettlementsParams) ([]ShopOrderSettlements, error) {
	rows, err := q.db.QueryContext(ctx, listPlatformSettlements,
		arg.StatusFilter,
		arg.StatusFilter,
		arg.StartDate,
		arg.EndDate,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShopOrderSettlements
	for rows.Next() {
		var i ShopOrderSettlements
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderID,
			&i.OrderTransactionID,
			&i.Status,
			&i.OrderSubtotal,
			&i.ShopFundedProductDiscount,
			&i.SiteFundedProductDiscount,
			&i.ShopVoucherDiscount,
			&i.ShopShippingDiscount,
			&i.ShippingFee,
			&i.CommissionFee,
			&i.NetSettledAmount,
			&i.OrderCompletedAt,
			&i.SettledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlatformTransactions = `-- name: ListPlatformTransactions :many
SELECT id, transaction_code, order_id, payment_method_id, amount, currency, type, status, gateway_transaction_id, notes, created_at, processed_at FROM transactions
WHERE
    (? IS NULL OR type = ?)
    AND (? IS NULL OR status = ?)
    AND (created_at BETWEEN ? AND ?)
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPlatformTransactionsParams struct {
	TypeFilter   NullTransactionsType   `json:"type_filter"`
	StatusFilter NullTransactionsStatus `json:"status_filter"`
	StartDate    sql.NullTime           `json:"start_date"`
	EndDate      sql.NullTime           `json:"end_date"`
	Limit        int32                  `json:"limit"`
	Offset       int32                  `json:"offset"`
}

// Tác dụng: Lấy tất cả giao dịch (API: GET /platform/finance/transactions)
// ĐÃ SỬA: Bỏ các cast '::text'
func (q *Queries) ListPlatformTransactions(ctx context.Context, arg ListPlatformTransactionsParams) ([]Transactions, error) {
	rows, err := q.db.QueryContext(ctx, listPlatformTransactions,
		arg.TypeFilter,
		arg.TypeFilter,
		arg.StatusFilter,
		arg.StatusFilter,
		arg.StartDate,
		arg.EndDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transactions
	for rows.Next() {
		var i Transactions
		if err := rows.Scan(
			&i.ID,
			&i.TransactionCode,
			&i.OrderID,
			&i.PaymentMethodID,
			&i.Amount,
			&i.Currency,
			&i.Type,
			&i.Status,
			&i.GatewayTransactionID,
			&i.Notes,
			&i.CreatedAt,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
