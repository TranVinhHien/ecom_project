// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shop_orders.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const cancelShopOrdersByIDs = `-- name: CancelShopOrdersByIDs :exec
UPDATE shop_orders
SET status = 'CANCELLED',
    cancellation_reason = ?, -- Tham số $1 (cancellation_reason)
    cancelled_at = NOW()
WHERE id IN (/*SLICE:shop_order_ids*/?)
`

type CancelShopOrdersByIDsParams struct {
	CancellationReason sql.NullString `json:"cancellation_reason"`
	ShopOrderIds       []string       `json:"shop_order_ids"`
}

// Cập nhật trạng thái một loạt shop_orders thành CANCELLED
func (q *Queries) CancelShopOrdersByIDs(ctx context.Context, arg CancelShopOrdersByIDsParams) error {
	query := cancelShopOrdersByIDs
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CancellationReason)
	if len(arg.ShopOrderIds) > 0 {
		for _, v := range arg.ShopOrderIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:shop_order_ids*/?", strings.Repeat(",?", len(arg.ShopOrderIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:shop_order_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const createShopOrder = `-- name: CreateShopOrder :exec

INSERT INTO shop_orders (
  id, shop_order_code, order_id, shop_id, status, subtotal, total_discount, total_amount, shipping_fee,
  shop_voucher_code, shop_voucher_discount, processing_at
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?
)
`

type CreateShopOrderParams struct {
	ID                  string           `json:"id"`
	ShopOrderCode       string           `json:"shop_order_code"`
	OrderID             string           `json:"order_id"`
	ShopID              string           `json:"shop_id"`
	Status              ShopOrdersStatus `json:"status"`
	Subtotal            string           `json:"subtotal"`
	TotalDiscount       string           `json:"total_discount"`
	TotalAmount         string           `json:"total_amount"`
	ShippingFee         string           `json:"shipping_fee"`
	ShopVoucherCode     sql.NullString   `json:"shop_voucher_code"`
	ShopVoucherDiscount sql.NullString   `json:"shop_voucher_discount"`
	ProcessingAt        sql.NullTime     `json:"processing_at"`
}

// =================================================================
// Queries for `shop_orders` table
// =================================================================
func (q *Queries) CreateShopOrder(ctx context.Context, arg CreateShopOrderParams) error {
	_, err := q.db.ExecContext(ctx, createShopOrder,
		arg.ID,
		arg.ShopOrderCode,
		arg.OrderID,
		arg.ShopID,
		arg.Status,
		arg.Subtotal,
		arg.TotalDiscount,
		arg.TotalAmount,
		arg.ShippingFee,
		arg.ShopVoucherCode,
		arg.ShopVoucherDiscount,
		arg.ProcessingAt,
	)
	return err
}

const getShopOrderByID = `-- name: GetShopOrderByID :one
SELECT id, shop_order_code, order_id, shop_id, status, subtotal, total_discount, total_amount, shop_voucher_code, shop_voucher_discount, shipping_fee, shipping_method, tracking_code, cancellation_reason, created_at, updated_at, paid_at, processing_at, shipped_at, completed_at, cancelled_at FROM shop_orders
WHERE id = ? LIMIT 1
`

func (q *Queries) GetShopOrderByID(ctx context.Context, id string) (ShopOrders, error) {
	row := q.db.QueryRowContext(ctx, getShopOrderByID, id)
	var i ShopOrders
	err := row.Scan(
		&i.ID,
		&i.ShopOrderCode,
		&i.OrderID,
		&i.ShopID,
		&i.Status,
		&i.Subtotal,
		&i.TotalDiscount,
		&i.TotalAmount,
		&i.ShopVoucherCode,
		&i.ShopVoucherDiscount,
		&i.ShippingFee,
		&i.ShippingMethod,
		&i.TrackingCode,
		&i.CancellationReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaidAt,
		&i.ProcessingAt,
		&i.ShippedAt,
		&i.CompletedAt,
		&i.CancelledAt,
	)
	return i, err
}

const listShopOrdersByOrderID = `-- name: ListShopOrdersByOrderID :many
SELECT id, shop_order_code, order_id, shop_id, status, subtotal, total_discount, total_amount, shop_voucher_code, shop_voucher_discount, shipping_fee, shipping_method, tracking_code, cancellation_reason, created_at, updated_at, paid_at, processing_at, shipped_at, completed_at, cancelled_at FROM shop_orders
WHERE (? IS NULL OR status = ?)
  AND order_id = ? 
ORDER BY created_at ASC
`

type ListShopOrdersByOrderIDParams struct {
	Status  NullShopOrdersStatus `json:"status"`
	OrderID string               `json:"order_id"`
}

func (q *Queries) ListShopOrdersByOrderID(ctx context.Context, arg ListShopOrdersByOrderIDParams) ([]ShopOrders, error) {
	rows, err := q.db.QueryContext(ctx, listShopOrdersByOrderID, arg.Status, arg.Status, arg.OrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShopOrders
	for rows.Next() {
		var i ShopOrders
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderCode,
			&i.OrderID,
			&i.ShopID,
			&i.Status,
			&i.Subtotal,
			&i.TotalDiscount,
			&i.TotalAmount,
			&i.ShopVoucherCode,
			&i.ShopVoucherDiscount,
			&i.ShippingFee,
			&i.ShippingMethod,
			&i.TrackingCode,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaidAt,
			&i.ProcessingAt,
			&i.ShippedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShopOrdersByShopIDPaged = `-- name: ListShopOrdersByShopIDPaged :many
SELECT id, shop_order_code, order_id, shop_id, status, subtotal, total_discount, total_amount, shop_voucher_code, shop_voucher_discount, shipping_fee, shipping_method, tracking_code, cancellation_reason, created_at, updated_at, paid_at, processing_at, shipped_at, completed_at, cancelled_at FROM shop_orders
WHERE shop_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListShopOrdersByShopIDPagedParams struct {
	ShopID string `json:"shop_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListShopOrdersByShopIDPaged(ctx context.Context, arg ListShopOrdersByShopIDPagedParams) ([]ShopOrders, error) {
	rows, err := q.db.QueryContext(ctx, listShopOrdersByShopIDPaged, arg.ShopID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShopOrders
	for rows.Next() {
		var i ShopOrders
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderCode,
			&i.OrderID,
			&i.ShopID,
			&i.Status,
			&i.Subtotal,
			&i.TotalDiscount,
			&i.TotalAmount,
			&i.ShopVoucherCode,
			&i.ShopVoucherDiscount,
			&i.ShippingFee,
			&i.ShippingMethod,
			&i.TrackingCode,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaidAt,
			&i.ProcessingAt,
			&i.ShippedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShopOrdersByStatus = `-- name: ListShopOrdersByStatus :many

SELECT shop_orders.id, shop_orders.shop_order_code, shop_orders.order_id, shop_orders.shop_id, shop_orders.status, shop_orders.subtotal, shop_orders.total_discount, shop_orders.total_amount, shop_orders.shop_voucher_code, shop_orders.shop_voucher_discount, shop_orders.shipping_fee, shop_orders.shipping_method, shop_orders.tracking_code, shop_orders.cancellation_reason, shop_orders.created_at, shop_orders.updated_at, shop_orders.paid_at, shop_orders.processing_at, shop_orders.shipped_at, shop_orders.completed_at, shop_orders.cancelled_at FROM shop_orders
JOIN orders ON shop_orders.order_id = orders.id
WHERE 
    -- 1. Nếu @status là NULL, vế (1) -> TRUE, bỏ qua điều kiện status
    -- 2. Nếu @status có giá trị (vd: 'PROCESSING'), vế (1) -> FALSE, 
    --    và vế (2) -> shop_orders.status = 'PROCESSING'
    (? IS NULL OR shop_orders.status = ?)
    
    AND orders.user_id = ?
ORDER BY 
    shop_orders.created_at DESC
LIMIT ? OFFSET ?
`

type ListShopOrdersByStatusParams struct {
	Status NullShopOrdersStatus `json:"status"`
	UserID string               `json:"user_id"`
	Limit  int32                `json:"limit"`
	Offset int32                `json:"offset"`
}

// -- name: ListShopOrdersByStatus :many
// SELECT shop_orders.* FROM shop_orders
// JOIN orders ON shop_orders.order_id = orders.id
// WHERE
//
//	shop_orders.status = ? AND orders.user_id = ?
//
// ORDER BY
//
//	shop_orders.created_at DESC
//
// LIMIT ? OFFSET ?;
func (q *Queries) ListShopOrdersByStatus(ctx context.Context, arg ListShopOrdersByStatusParams) ([]ShopOrders, error) {
	rows, err := q.db.QueryContext(ctx, listShopOrdersByStatus,
		arg.Status,
		arg.Status,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShopOrders
	for rows.Next() {
		var i ShopOrders
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderCode,
			&i.OrderID,
			&i.ShopID,
			&i.Status,
			&i.Subtotal,
			&i.TotalDiscount,
			&i.TotalAmount,
			&i.ShopVoucherCode,
			&i.ShopVoucherDiscount,
			&i.ShippingFee,
			&i.ShippingMethod,
			&i.TrackingCode,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaidAt,
			&i.ProcessingAt,
			&i.ShippedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShopOrdersByStatusCount = `-- name: ListShopOrdersByStatusCount :one

SELECT COUNT(*) FROM shop_orders
JOIN orders ON shop_orders.order_id = orders.id
WHERE 
    (? IS NULL OR shop_orders.status = ?)
   AND orders.user_id = ?
`

type ListShopOrdersByStatusCountParams struct {
	Status NullShopOrdersStatus `json:"status"`
	UserID string               `json:"user_id"`
}

func (q *Queries) ListShopOrdersByStatusCount(ctx context.Context, arg ListShopOrdersByStatusCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, listShopOrdersByStatusCount, arg.Status, arg.Status, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchShopOrders = `-- name: SearchShopOrders :many
SELECT shop_orders.id, shop_orders.shop_order_code, shop_orders.order_id, shop_orders.shop_id, shop_orders.status, shop_orders.subtotal, shop_orders.total_discount, shop_orders.total_amount, shop_orders.shop_voucher_code, shop_orders.shop_voucher_discount, shop_orders.shipping_fee, shop_orders.shipping_method, shop_orders.tracking_code, shop_orders.cancellation_reason, shop_orders.created_at, shop_orders.updated_at, shop_orders.paid_at, shop_orders.processing_at, shop_orders.shipped_at, shop_orders.completed_at, shop_orders.cancelled_at FROM shop_orders
JOIN orders ON shop_orders.order_id = orders.id
WHERE 
  -- Lọc theo user_id từ bảng orders
  orders.user_id = ?
  
  -- Lọc theo status (nếu có)
  AND (? IS NULL OR shop_orders.status = ?)
  
  -- Lọc theo shop_id (nếu có)
  AND (? IS NULL OR shop_orders.shop_id = ?)
  
  -- Lọc theo khoảng tổng tiền (min_amount và max_amount)
  AND (? IS NULL OR shop_orders.total_amount >= ?)
  AND (? IS NULL OR shop_orders.total_amount <= ?)
  
  -- Lọc theo khoảng thời gian created_at
  AND (? IS NULL OR shop_orders.created_at >= ?)
  AND (? IS NULL OR shop_orders.created_at <= ?)
  
  -- Lọc theo khoảng thời gian paid_at
  AND (? IS NULL OR shop_orders.paid_at >= ?)
  AND (? IS NULL OR shop_orders.paid_at <= ?)
  
  -- Lọc theo khoảng thời gian processing_at
  AND (? IS NULL OR shop_orders.processing_at >= ?)
  AND (? IS NULL OR shop_orders.processing_at <= ?)
  
  -- Lọc theo khoảng thời gian shipped_at
  AND (? IS NULL OR shop_orders.shipped_at >= ?)
  AND (? IS NULL OR shop_orders.shipped_at <= ?)
  
  -- Lọc theo khoảng thời gian completed_at
  AND (? IS NULL OR shop_orders.completed_at >= ?)
  AND (? IS NULL OR shop_orders.completed_at <= ?)
  
  -- Lọc theo khoảng thời gian cancelled_at
  AND (? IS NULL OR shop_orders.cancelled_at >= ?)
  AND (? IS NULL OR shop_orders.cancelled_at <= ?)
  
ORDER BY 
  CASE ?
    WHEN 'created_at' THEN shop_orders.created_at
    WHEN 'total_amount' THEN shop_orders.total_amount
    WHEN 'paid_at' THEN shop_orders.paid_at
    WHEN 'processing_at' THEN shop_orders.processing_at
    WHEN 'shipped_at' THEN shop_orders.shipped_at
    WHEN 'completed_at' THEN shop_orders.completed_at
    ELSE shop_orders.created_at
  END DESC
LIMIT ? OFFSET ?
`

type SearchShopOrdersParams struct {
	UserID         string               `json:"user_id"`
	Status         NullShopOrdersStatus `json:"status"`
	ShopID         sql.NullString       `json:"shop_id"`
	MinAmount      sql.NullString       `json:"min_amount"`
	MaxAmount      sql.NullString       `json:"max_amount"`
	CreatedFrom    sql.NullTime         `json:"created_from"`
	CreatedTo      sql.NullTime         `json:"created_to"`
	PaidFrom       sql.NullTime         `json:"paid_from"`
	PaidTo         sql.NullTime         `json:"paid_to"`
	ProcessingFrom sql.NullTime         `json:"processing_from"`
	ProcessingTo   sql.NullTime         `json:"processing_to"`
	ShippedFrom    sql.NullTime         `json:"shipped_from"`
	ShippedTo      sql.NullTime         `json:"shipped_to"`
	CompletedFrom  sql.NullTime         `json:"completed_from"`
	CompletedTo    sql.NullTime         `json:"completed_to"`
	CancelledFrom  sql.NullTime         `json:"cancelled_from"`
	CancelledTo    sql.NullTime         `json:"cancelled_to"`
	SortBy         interface{}          `json:"sort_by"`
	Limit          int32                `json:"limit"`
	Offset         int32                `json:"offset"`
}

func (q *Queries) SearchShopOrders(ctx context.Context, arg SearchShopOrdersParams) ([]ShopOrders, error) {
	rows, err := q.db.QueryContext(ctx, searchShopOrders,
		arg.UserID,
		arg.Status,
		arg.Status,
		arg.ShopID,
		arg.ShopID,
		arg.MinAmount,
		arg.MinAmount,
		arg.MaxAmount,
		arg.MaxAmount,
		arg.CreatedFrom,
		arg.CreatedFrom,
		arg.CreatedTo,
		arg.CreatedTo,
		arg.PaidFrom,
		arg.PaidFrom,
		arg.PaidTo,
		arg.PaidTo,
		arg.ProcessingFrom,
		arg.ProcessingFrom,
		arg.ProcessingTo,
		arg.ProcessingTo,
		arg.ShippedFrom,
		arg.ShippedFrom,
		arg.ShippedTo,
		arg.ShippedTo,
		arg.CompletedFrom,
		arg.CompletedFrom,
		arg.CompletedTo,
		arg.CompletedTo,
		arg.CancelledFrom,
		arg.CancelledFrom,
		arg.CancelledTo,
		arg.CancelledTo,
		arg.SortBy,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShopOrders
	for rows.Next() {
		var i ShopOrders
		if err := rows.Scan(
			&i.ID,
			&i.ShopOrderCode,
			&i.OrderID,
			&i.ShopID,
			&i.Status,
			&i.Subtotal,
			&i.TotalDiscount,
			&i.TotalAmount,
			&i.ShopVoucherCode,
			&i.ShopVoucherDiscount,
			&i.ShippingFee,
			&i.ShippingMethod,
			&i.TrackingCode,
			&i.CancellationReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PaidAt,
			&i.ProcessingAt,
			&i.ShippedAt,
			&i.CompletedAt,
			&i.CancelledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchShopOrdersCount = `-- name: SearchShopOrdersCount :one
SELECT COUNT(*) FROM shop_orders
JOIN orders ON shop_orders.order_id = orders.id
WHERE 
  -- Lọc theo user_id từ bảng orders
  orders.user_id = ?
  
  -- Lọc theo status (nếu có)
  AND (? IS NULL OR shop_orders.status = ?)
  
  -- Lọc theo shop_id (nếu có)
  AND (? IS NULL OR shop_orders.shop_id = ?)
  
  -- Lọc theo khoảng tổng tiền (min_amount và max_amount)
  AND (? IS NULL OR shop_orders.total_amount >= ?)
  AND (? IS NULL OR shop_orders.total_amount <= ?)
  
  -- Lọc theo khoảng thời gian created_at
  AND (? IS NULL OR shop_orders.created_at >= ?)
  AND (? IS NULL OR shop_orders.created_at <= ?)
  
  -- Lọc theo khoảng thời gian paid_at
  AND (? IS NULL OR shop_orders.paid_at >= ?)
  AND (? IS NULL OR shop_orders.paid_at <= ?)
  
  -- Lọc theo khoảng thời gian processing_at
  AND (? IS NULL OR shop_orders.processing_at >= ?)
  AND (? IS NULL OR shop_orders.processing_at <= ?)
  
  -- Lọc theo khoảng thời gian shipped_at
  AND (? IS NULL OR shop_orders.shipped_at >= ?)
  AND (? IS NULL OR shop_orders.shipped_at <= ?)
  
  -- Lọc theo khoảng thời gian completed_at
  AND (? IS NULL OR shop_orders.completed_at >= ?)
  AND (? IS NULL OR shop_orders.completed_at <= ?)
  
  -- Lọc theo khoảng thời gian cancelled_at
  AND (? IS NULL OR shop_orders.cancelled_at >= ?)
  AND (? IS NULL OR shop_orders.cancelled_at <= ?)
`

type SearchShopOrdersCountParams struct {
	UserID         string               `json:"user_id"`
	Status         NullShopOrdersStatus `json:"status"`
	ShopID         sql.NullString       `json:"shop_id"`
	MinAmount      sql.NullString       `json:"min_amount"`
	MaxAmount      sql.NullString       `json:"max_amount"`
	CreatedFrom    sql.NullTime         `json:"created_from"`
	CreatedTo      sql.NullTime         `json:"created_to"`
	PaidFrom       sql.NullTime         `json:"paid_from"`
	PaidTo         sql.NullTime         `json:"paid_to"`
	ProcessingFrom sql.NullTime         `json:"processing_from"`
	ProcessingTo   sql.NullTime         `json:"processing_to"`
	ShippedFrom    sql.NullTime         `json:"shipped_from"`
	ShippedTo      sql.NullTime         `json:"shipped_to"`
	CompletedFrom  sql.NullTime         `json:"completed_from"`
	CompletedTo    sql.NullTime         `json:"completed_to"`
	CancelledFrom  sql.NullTime         `json:"cancelled_from"`
	CancelledTo    sql.NullTime         `json:"cancelled_to"`
}

func (q *Queries) SearchShopOrdersCount(ctx context.Context, arg SearchShopOrdersCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, searchShopOrdersCount,
		arg.UserID,
		arg.Status,
		arg.Status,
		arg.ShopID,
		arg.ShopID,
		arg.MinAmount,
		arg.MinAmount,
		arg.MaxAmount,
		arg.MaxAmount,
		arg.CreatedFrom,
		arg.CreatedFrom,
		arg.CreatedTo,
		arg.CreatedTo,
		arg.PaidFrom,
		arg.PaidFrom,
		arg.PaidTo,
		arg.PaidTo,
		arg.ProcessingFrom,
		arg.ProcessingFrom,
		arg.ProcessingTo,
		arg.ProcessingTo,
		arg.ShippedFrom,
		arg.ShippedFrom,
		arg.ShippedTo,
		arg.ShippedTo,
		arg.CompletedFrom,
		arg.CompletedFrom,
		arg.CompletedTo,
		arg.CompletedTo,
		arg.CancelledFrom,
		arg.CancelledFrom,
		arg.CancelledTo,
		arg.CancelledTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateShopOrderGeneralInfo = `-- name: UpdateShopOrderGeneralInfo :exec
UPDATE shop_orders
SET
  shipping_method = COALESCE(?, shipping_method),
  tracking_code = COALESCE(?, tracking_code),
  updated_at = NOW()
WHERE id = ?
`

type UpdateShopOrderGeneralInfoParams struct {
	ShippingMethod sql.NullString `json:"shipping_method"`
	TrackingCode   sql.NullString `json:"tracking_code"`
	ID             string         `json:"id"`
}

func (q *Queries) UpdateShopOrderGeneralInfo(ctx context.Context, arg UpdateShopOrderGeneralInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateShopOrderGeneralInfo, arg.ShippingMethod, arg.TrackingCode, arg.ID)
	return err
}

const updateShopOrderStatusToCancelled = `-- name: UpdateShopOrderStatusToCancelled :exec
UPDATE shop_orders
SET
  status = 'CANCELLED',
  cancelled_at = NOW(),
  cancellation_reason = ?,
  updated_at = NOW()
WHERE id = ?
`

type UpdateShopOrderStatusToCancelledParams struct {
	CancellationReason sql.NullString `json:"cancellation_reason"`
	ID                 string         `json:"id"`
}

func (q *Queries) UpdateShopOrderStatusToCancelled(ctx context.Context, arg UpdateShopOrderStatusToCancelledParams) error {
	_, err := q.db.ExecContext(ctx, updateShopOrderStatusToCancelled, arg.CancellationReason, arg.ID)
	return err
}

const updateShopOrderStatusToCompleted = `-- name: UpdateShopOrderStatusToCompleted :exec
UPDATE shop_orders
SET
  status = 'COMPLETED',
  completed_at = NOW(),
  updated_at = NOW()
WHERE id = ?
`

func (q *Queries) UpdateShopOrderStatusToCompleted(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateShopOrderStatusToCompleted, id)
	return err
}

const updateShopOrderStatusToProcessing = `-- name: UpdateShopOrderStatusToProcessing :exec
UPDATE shop_orders
SET
  status = 'PROCESSING',
  processing_at = NOW(),
  paid_at = NOW(),
  updated_at = NOW()
WHERE id = ?
`

func (q *Queries) UpdateShopOrderStatusToProcessing(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateShopOrderStatusToProcessing, id)
	return err
}

const updateShopOrderStatusToRefunded = `-- name: UpdateShopOrderStatusToRefunded :exec
UPDATE shop_orders
SET
  status = 'REFUNDED',
  processing_at = NOW(),
  updated_at = NOW()
WHERE id = ?
`

func (q *Queries) UpdateShopOrderStatusToRefunded(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateShopOrderStatusToRefunded, id)
	return err
}

const updateShopOrderStatusToShipped = `-- name: UpdateShopOrderStatusToShipped :exec
UPDATE shop_orders
SET
  status = 'SHIPPED',
  shipped_at = NOW(),
  tracking_code = ?,
  shipping_method = ?,
  updated_at = NOW()
WHERE id = ?
`

type UpdateShopOrderStatusToShippedParams struct {
	TrackingCode   sql.NullString `json:"tracking_code"`
	ShippingMethod sql.NullString `json:"shipping_method"`
	ID             string         `json:"id"`
}

func (q *Queries) UpdateShopOrderStatusToShipped(ctx context.Context, arg UpdateShopOrderStatusToShippedParams) error {
	_, err := q.db.ExecContext(ctx, updateShopOrderStatusToShipped, arg.TrackingCode, arg.ShippingMethod, arg.ID)
	return err
}
