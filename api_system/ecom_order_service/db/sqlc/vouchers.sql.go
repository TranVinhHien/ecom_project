// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vouchers.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countVoucherUsageByUser = `-- name: CountVoucherUsageByUser :one
SELECT COUNT(*) FROM voucher_usage_history
WHERE
    voucher_id = ? AND user_id = ?
`

type CountVoucherUsageByUserParams struct {
	VoucherID string `json:"voucher_id"`
	UserID    string `json:"user_id"`
}

// Đếm số lần user đã sử dụng 1 voucher (cho check max_usage_per_user)
func (q *Queries) CountVoucherUsageByUser(ctx context.Context, arg CountVoucherUsageByUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVoucherUsageByUser, arg.VoucherID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVoucher = `-- name: CreateVoucher :exec
INSERT INTO vouchers (
    id,
    name,
    voucher_code,
    owner_type,
    owner_id,
    discount_type,
    discount_value,
    max_discount_amount,
    applies_to_type,
    min_purchase_amount,
    audience_type,
    start_date,
    end_date,
    total_quantity,
    max_usage_per_user,
    is_active
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateVoucherParams struct {
	ID                string                `json:"id"`
	Name              string                `json:"name"`
	VoucherCode       string                `json:"voucher_code"`
	OwnerType         VouchersOwnerType     `json:"owner_type"`
	OwnerID           string                `json:"owner_id"`
	DiscountType      VouchersDiscountType  `json:"discount_type"`
	DiscountValue     string                `json:"discount_value"`
	MaxDiscountAmount sql.NullString        `json:"max_discount_amount"`
	AppliesToType     VouchersAppliesToType `json:"applies_to_type"`
	MinPurchaseAmount string                `json:"min_purchase_amount"`
	AudienceType      VouchersAudienceType  `json:"audience_type"`
	StartDate         time.Time             `json:"start_date"`
	EndDate           time.Time             `json:"end_date"`
	TotalQuantity     int32                 `json:"total_quantity"`
	MaxUsagePerUser   int32                 `json:"max_usage_per_user"`
	IsActive          bool                  `json:"is_active"`
}

func (q *Queries) CreateVoucher(ctx context.Context, arg CreateVoucherParams) error {
	_, err := q.db.ExecContext(ctx, createVoucher,
		arg.ID,
		arg.Name,
		arg.VoucherCode,
		arg.OwnerType,
		arg.OwnerID,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MaxDiscountAmount,
		arg.AppliesToType,
		arg.MinPurchaseAmount,
		arg.AudienceType,
		arg.StartDate,
		arg.EndDate,
		arg.TotalQuantity,
		arg.MaxUsagePerUser,
		arg.IsActive,
	)
	return err
}

const createVoucherUsageHistory = `-- name: CreateVoucherUsageHistory :exec
INSERT INTO voucher_usage_history (
    voucher_id,
    user_id,
    discount_amount
) VALUES (
    ?, ?, ?
)
`

type CreateVoucherUsageHistoryParams struct {
	VoucherID      string `json:"voucher_id"`
	UserID         string `json:"user_id"`
	DiscountAmount string `json:"discount_amount"`
}

// Ghi lại lịch sử sử dụng voucher
func (q *Queries) CreateVoucherUsageHistory(ctx context.Context, arg CreateVoucherUsageHistoryParams) error {
	_, err := q.db.ExecContext(ctx, createVoucherUsageHistory, arg.VoucherID, arg.UserID, arg.DiscountAmount)
	return err
}

const decrementVoucherUsage = `-- name: DecrementVoucherUsage :execrows
UPDATE vouchers
SET
    used_quantity = used_quantity - 1
WHERE
    id = ? AND used_quantity > 0
`

// Giảm số lượng đã dùng (khi hủy đơn)
func (q *Queries) DecrementVoucherUsage(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, decrementVoucherUsage, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteVoucherUsageHistory = `-- name: DeleteVoucherUsageHistory :execrows
DELETE FROM voucher_usage_history
WHERE
    id = ?
`

// Xóa 1 dòng lịch sử cụ thể (khi hủy đơn)
func (q *Queries) DeleteVoucherUsageHistory(ctx context.Context, id uint64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteVoucherUsageHistory, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAssignedVouchersByUser = `-- name: GetAssignedVouchersByUser :many
SELECT v.id, v.name, v.voucher_code, v.owner_type, v.owner_id, v.discount_type, v.discount_value, v.max_discount_amount, v.applies_to_type, v.min_purchase_amount, v.audience_type, v.start_date, v.end_date, v.total_quantity, v.used_quantity, v.max_usage_per_user, v.is_active, v.created_at, v.updated_at
FROM vouchers v
JOIN user_vouchers uv ON v.id = uv.voucher_id
WHERE
    uv.user_id = ?
    AND uv.status = 'AVAILABLE'
    AND v.is_active = TRUE
    AND NOW() BETWEEN v.start_date AND v.end_date
ORDER BY
    v.created_at DESC
`

// Lấy danh sách voucher ĐƯỢC GÁN RIÊNG (cho 1 user)
// Chỉ lấy voucher còn hiệu lực, còn trạng thái AVAILABLE
func (q *Queries) GetAssignedVouchersByUser(ctx context.Context, userID string) ([]Vouchers, error) {
	rows, err := q.db.QueryContext(ctx, getAssignedVouchersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vouchers
	for rows.Next() {
		var i Vouchers
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.VoucherCode,
			&i.OwnerType,
			&i.OwnerID,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MaxDiscountAmount,
			&i.AppliesToType,
			&i.MinPurchaseAmount,
			&i.AudienceType,
			&i.StartDate,
			&i.EndDate,
			&i.TotalQuantity,
			&i.UsedQuantity,
			&i.MaxUsagePerUser,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssignedVouchersByUserWithFilter = `-- name: GetAssignedVouchersByUserWithFilter :many
SELECT v.id, v.name, v.voucher_code, v.owner_type, v.owner_id, v.discount_type, v.discount_value, v.max_discount_amount, v.applies_to_type, v.min_purchase_amount, v.audience_type, v.start_date, v.end_date, v.total_quantity, v.used_quantity, v.max_usage_per_user, v.is_active, v.created_at, v.updated_at
FROM vouchers v
JOIN user_vouchers uv ON v.id = uv.voucher_id
WHERE
    uv.user_id = ?
    AND uv.status = 'AVAILABLE'
    AND v.is_active = TRUE
    AND NOW() BETWEEN v.start_date AND v.end_date
    AND (? IS NULL OR v.owner_type = ?)
    AND (? IS NULL OR v.owner_id = ?)
    AND (? IS NULL OR v.applies_to_type = ?)
ORDER BY
    CASE 
        WHEN ? = 'discount_asc' THEN v.discount_value
    END ASC,
    CASE 
        WHEN ? = 'discount_desc' THEN v.discount_value
    END DESC,
    CASE 
        WHEN ? = 'created_at' OR ? = '' THEN v.created_at
    END DESC
`

type GetAssignedVouchersByUserWithFilterParams struct {
	UserID        string                    `json:"user_id"`
	OwnerType     NullVouchersOwnerType     `json:"owner_type"`
	ShopID        sql.NullString            `json:"shop_id"`
	AppliesToType NullVouchersAppliesToType `json:"applies_to_type"`
	SortBy        interface{}               `json:"sort_by"`
}

// Lấy danh sách voucher ĐƯỢC GÁN RIÊNG với bộ lọc
func (q *Queries) GetAssignedVouchersByUserWithFilter(ctx context.Context, arg GetAssignedVouchersByUserWithFilterParams) ([]Vouchers, error) {
	rows, err := q.db.QueryContext(ctx, getAssignedVouchersByUserWithFilter,
		arg.UserID,
		arg.OwnerType,
		arg.OwnerType,
		arg.ShopID,
		arg.ShopID,
		arg.AppliesToType,
		arg.AppliesToType,
		arg.SortBy,
		arg.SortBy,
		arg.SortBy,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vouchers
	for rows.Next() {
		var i Vouchers
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.VoucherCode,
			&i.OwnerType,
			&i.OwnerID,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MaxDiscountAmount,
			&i.AppliesToType,
			&i.MinPurchaseAmount,
			&i.AudienceType,
			&i.StartDate,
			&i.EndDate,
			&i.TotalQuantity,
			&i.UsedQuantity,
			&i.MaxUsagePerUser,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicVouchers = `-- name: GetPublicVouchers :many
SELECT id, name, voucher_code, owner_type, owner_id, discount_type, discount_value, max_discount_amount, applies_to_type, min_purchase_amount, audience_type, start_date, end_date, total_quantity, used_quantity, max_usage_per_user, is_active, created_at, updated_at FROM vouchers
WHERE
    audience_type = 'PUBLIC'
    AND is_active = TRUE
    AND NOW() BETWEEN start_date AND end_date
    AND used_quantity < total_quantity
ORDER BY
    created_at DESC
`

// Lấy danh sách voucher CÔNG KHAI (cho toàn bộ người dùng)
// Chỉ lấy voucher còn hiệu lực và còn số lượng
func (q *Queries) GetPublicVouchers(ctx context.Context) ([]Vouchers, error) {
	rows, err := q.db.QueryContext(ctx, getPublicVouchers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vouchers
	for rows.Next() {
		var i Vouchers
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.VoucherCode,
			&i.OwnerType,
			&i.OwnerID,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MaxDiscountAmount,
			&i.AppliesToType,
			&i.MinPurchaseAmount,
			&i.AudienceType,
			&i.StartDate,
			&i.EndDate,
			&i.TotalQuantity,
			&i.UsedQuantity,
			&i.MaxUsagePerUser,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicVouchersWithFilter = `-- name: GetPublicVouchersWithFilter :many
SELECT id, name, voucher_code, owner_type, owner_id, discount_type, discount_value, max_discount_amount, applies_to_type, min_purchase_amount, audience_type, start_date, end_date, total_quantity, used_quantity, max_usage_per_user, is_active, created_at, updated_at FROM vouchers
WHERE
    audience_type = 'PUBLIC'
    AND is_active = TRUE
    AND NOW() BETWEEN start_date AND end_date
    AND used_quantity < total_quantity
    AND (? IS NULL OR owner_type = ?)
    AND (? IS NULL OR owner_id = ?)
    AND (? IS NULL OR applies_to_type = ?)
ORDER BY
    CASE 
        WHEN ? = 'discount_asc' THEN discount_value
    END ASC,
    CASE 
        WHEN ? = 'discount_desc' THEN discount_value
    END DESC,
    CASE 
        WHEN ? = 'created_at' OR ? = '' THEN created_at
    END DESC
`

type GetPublicVouchersWithFilterParams struct {
	OwnerType     NullVouchersOwnerType     `json:"owner_type"`
	ShopID        sql.NullString            `json:"shop_id"`
	AppliesToType NullVouchersAppliesToType `json:"applies_to_type"`
	SortBy        interface{}               `json:"sort_by"`
}

// Lấy danh sách voucher CÔNG KHAI với bộ lọc
func (q *Queries) GetPublicVouchersWithFilter(ctx context.Context, arg GetPublicVouchersWithFilterParams) ([]Vouchers, error) {
	rows, err := q.db.QueryContext(ctx, getPublicVouchersWithFilter,
		arg.OwnerType,
		arg.OwnerType,
		arg.ShopID,
		arg.ShopID,
		arg.AppliesToType,
		arg.AppliesToType,
		arg.SortBy,
		arg.SortBy,
		arg.SortBy,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vouchers
	for rows.Next() {
		var i Vouchers
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.VoucherCode,
			&i.OwnerType,
			&i.OwnerID,
			&i.DiscountType,
			&i.DiscountValue,
			&i.MaxDiscountAmount,
			&i.AppliesToType,
			&i.MinPurchaseAmount,
			&i.AudienceType,
			&i.StartDate,
			&i.EndDate,
			&i.TotalQuantity,
			&i.UsedQuantity,
			&i.MaxUsagePerUser,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserVoucherStatus = `-- name: GetUserVoucherStatus :one
SELECT id, user_id, voucher_id, status FROM user_vouchers
WHERE
    voucher_id = ? AND user_id = ?
LIMIT 1
`

type GetUserVoucherStatusParams struct {
	VoucherID string `json:"voucher_id"`
	UserID    string `json:"user_id"`
}

// Lấy trạng thái voucher trong ví của user (cho check voucher ĐƯỢC GÁN)
func (q *Queries) GetUserVoucherStatus(ctx context.Context, arg GetUserVoucherStatusParams) (UserVouchers, error) {
	row := q.db.QueryRowContext(ctx, getUserVoucherStatus, arg.VoucherID, arg.UserID)
	var i UserVouchers
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VoucherID,
		&i.Status,
	)
	return i, err
}

const getVoucherByID = `-- name: GetVoucherByID :one
SELECT id, name, voucher_code, owner_type, owner_id, discount_type, discount_value, max_discount_amount, applies_to_type, min_purchase_amount, audience_type, start_date, end_date, total_quantity, used_quantity, max_usage_per_user, is_active, created_at, updated_at FROM vouchers WHERE id = ? LIMIT 1
`

// Lấy voucher bằng ID (không check điều kiện)
func (q *Queries) GetVoucherByID(ctx context.Context, id string) (Vouchers, error) {
	row := q.db.QueryRowContext(ctx, getVoucherByID, id)
	var i Vouchers
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.VoucherCode,
		&i.OwnerType,
		&i.OwnerID,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MaxDiscountAmount,
		&i.AppliesToType,
		&i.MinPurchaseAmount,
		&i.AudienceType,
		&i.StartDate,
		&i.EndDate,
		&i.TotalQuantity,
		&i.UsedQuantity,
		&i.MaxUsagePerUser,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVoucherByIDForValidation = `-- name: GetVoucherByIDForValidation :one
SELECT id, name, voucher_code, owner_type, owner_id, discount_type, discount_value, max_discount_amount, applies_to_type, min_purchase_amount, audience_type, start_date, end_date, total_quantity, used_quantity, max_usage_per_user, is_active, created_at, updated_at FROM vouchers
WHERE
    id = ?
    AND is_active = TRUE
    AND NOW() BETWEEN start_date AND end_date
    AND used_quantity < total_quantity
LIMIT 1
`

// Lấy thông tin voucher bằng ID để kiểm tra (THÊM MỚI)
// Chỉ trả về voucher nếu nó CƠ BẢN hợp lệ (còn hạn, còn lượt)
func (q *Queries) GetVoucherByIDForValidation(ctx context.Context, id string) (Vouchers, error) {
	row := q.db.QueryRowContext(ctx, getVoucherByIDForValidation, id)
	var i Vouchers
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.VoucherCode,
		&i.OwnerType,
		&i.OwnerID,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MaxDiscountAmount,
		&i.AppliesToType,
		&i.MinPurchaseAmount,
		&i.AudienceType,
		&i.StartDate,
		&i.EndDate,
		&i.TotalQuantity,
		&i.UsedQuantity,
		&i.MaxUsagePerUser,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVoucherForValidation = `-- name: GetVoucherForValidation :one

SELECT id, name, voucher_code, owner_type, owner_id, discount_type, discount_value, max_discount_amount, applies_to_type, min_purchase_amount, audience_type, start_date, end_date, total_quantity, used_quantity, max_usage_per_user, is_active, created_at, updated_at FROM vouchers
WHERE
    voucher_code = ?
    AND is_active = TRUE
    AND NOW() BETWEEN start_date AND end_date
    AND used_quantity < total_quantity
LIMIT 1
`

// =============================================
// CÁC HÀM LẤY DỮ LIỆU ĐỂ "CHECK" TRONG CODE LOGIC
// =============================================
// Lấy thông tin voucher bằng MÃ (code) để kiểm tra
// Chỉ trả về voucher nếu nó CƠ BẢN hợp lệ (còn hạn, còn lượt)
func (q *Queries) GetVoucherForValidation(ctx context.Context, voucherCode string) (Vouchers, error) {
	row := q.db.QueryRowContext(ctx, getVoucherForValidation, voucherCode)
	var i Vouchers
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.VoucherCode,
		&i.OwnerType,
		&i.OwnerID,
		&i.DiscountType,
		&i.DiscountValue,
		&i.MaxDiscountAmount,
		&i.AppliesToType,
		&i.MinPurchaseAmount,
		&i.AudienceType,
		&i.StartDate,
		&i.EndDate,
		&i.TotalQuantity,
		&i.UsedQuantity,
		&i.MaxUsagePerUser,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVoucherUsageHistory = `-- name: GetVoucherUsageHistory :one
SELECT id, voucher_id, user_id, discount_amount, used_at FROM voucher_usage_history
WHERE
    voucher_id = ? 
    AND user_id = ? 
LIMIT 1
`

type GetVoucherUsageHistoryParams struct {
	VoucherID string `json:"voucher_id"`
	UserID    string `json:"user_id"`
}

// Lấy 1 dòng lịch sử sử dụng cụ thể
func (q *Queries) GetVoucherUsageHistory(ctx context.Context, arg GetVoucherUsageHistoryParams) (VoucherUsageHistory, error) {
	row := q.db.QueryRowContext(ctx, getVoucherUsageHistory, arg.VoucherID, arg.UserID)
	var i VoucherUsageHistory
	err := row.Scan(
		&i.ID,
		&i.VoucherID,
		&i.UserID,
		&i.DiscountAmount,
		&i.UsedAt,
	)
	return i, err
}

const incrementVoucherUsage = `-- name: IncrementVoucherUsage :execrows

UPDATE vouchers
SET
    used_quantity = used_quantity + 1
WHERE
    id = ? AND used_quantity < total_quantity
`

// =============================================
// CÁC HÀM "COMMAND" KHI TẠO ĐƠN HÀNG
// =============================================
// Tăng số lượng đã dùng. Dùng :execrows để check race condition
// (Logic code phải kiểm tra RowsAffected() == 1)
func (q *Queries) IncrementVoucherUsage(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, incrementVoucherUsage, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const resetUserVoucherStatus = `-- name: ResetUserVoucherStatus :execrows

UPDATE user_vouchers
SET
    status = 'AVAILABLE'
WHERE
    voucher_id = ?
    AND user_id = ?
    AND status = 'USED'
`

type ResetUserVoucherStatusParams struct {
	VoucherID string `json:"voucher_id"`
	UserID    string `json:"user_id"`
}

// Xóa bằng ID của bảng history
// Reset trạng thái ví voucher (từ USED về AVAILABLE)
func (q *Queries) ResetUserVoucherStatus(ctx context.Context, arg ResetUserVoucherStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetUserVoucherStatus, arg.VoucherID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setUserVoucherStatus = `-- name: SetUserVoucherStatus :execrows
UPDATE user_vouchers
SET
    status = ?
WHERE
    voucher_id = ?
    AND user_id = ?
    AND status = 'AVAILABLE'
`

type SetUserVoucherStatusParams struct {
	Status    UserVouchersStatus `json:"status"`
	VoucherID string             `json:"voucher_id"`
	UserID    string             `json:"user_id"`
}

// Cập nhật trạng thái voucher trong ví user (từ AVAILABLE -> USED)
// (Logic code nên kiểm tra RowsAffected() == 1)
func (q *Queries) SetUserVoucherStatus(ctx context.Context, arg SetUserVoucherStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, setUserVoucherStatus, arg.Status, arg.VoucherID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateVoucher = `-- name: UpdateVoucher :exec
UPDATE vouchers
SET
    name = COALESCE(?, name),
    voucher_code = COALESCE(?, voucher_code),
    discount_type = COALESCE(?, discount_type),
    discount_value = COALESCE(?, discount_value),
    max_discount_amount = COALESCE(?, max_discount_amount),
    applies_to_type = COALESCE(?, applies_to_type),
    min_purchase_amount = COALESCE(?, min_purchase_amount),
    audience_type = COALESCE(?, audience_type),
    start_date = COALESCE(?, start_date),
    end_date = COALESCE(?, end_date),
    total_quantity = COALESCE(?, total_quantity),
    max_usage_per_user = COALESCE(?, max_usage_per_user),
    is_active = COALESCE(?, is_active)
WHERE
    id = ?
`

type UpdateVoucherParams struct {
	Name              sql.NullString            `json:"name"`
	VoucherCode       sql.NullString            `json:"voucher_code"`
	DiscountType      NullVouchersDiscountType  `json:"discount_type"`
	DiscountValue     sql.NullString            `json:"discount_value"`
	MaxDiscountAmount sql.NullString            `json:"max_discount_amount"`
	AppliesToType     NullVouchersAppliesToType `json:"applies_to_type"`
	MinPurchaseAmount sql.NullString            `json:"min_purchase_amount"`
	AudienceType      NullVouchersAudienceType  `json:"audience_type"`
	StartDate         sql.NullTime              `json:"start_date"`
	EndDate           sql.NullTime              `json:"end_date"`
	TotalQuantity     sql.NullInt32             `json:"total_quantity"`
	MaxUsagePerUser   sql.NullInt32             `json:"max_usage_per_user"`
	IsActive          sql.NullBool              `json:"is_active"`
	ID                string                    `json:"id"`
}

// Cập nhật từng phần (Partial Update)
func (q *Queries) UpdateVoucher(ctx context.Context, arg UpdateVoucherParams) error {
	_, err := q.db.ExecContext(ctx, updateVoucher,
		arg.Name,
		arg.VoucherCode,
		arg.DiscountType,
		arg.DiscountValue,
		arg.MaxDiscountAmount,
		arg.AppliesToType,
		arg.MinPurchaseAmount,
		arg.AudienceType,
		arg.StartDate,
		arg.EndDate,
		arg.TotalQuantity,
		arg.MaxUsagePerUser,
		arg.IsActive,
		arg.ID,
	)
	return err
}
