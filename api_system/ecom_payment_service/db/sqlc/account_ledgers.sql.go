// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account_ledgers.sql

package db

import (
	"context"
)

const createLedger = `-- name: CreateLedger :exec

INSERT INTO account_ledgers (
  id, owner_id, owner_type
) VALUES (
  ?, ?, ?
)
`

type CreateLedgerParams struct {
	ID        string                  `json:"id"`
	OwnerID   string                  `json:"owner_id"`
	OwnerType AccountLedgersOwnerType `json:"owner_type"`
}

// =================================================================
// Queries for `account_ledgers` table
// =================================================================
func (q *Queries) CreateLedger(ctx context.Context, arg CreateLedgerParams) error {
	_, err := q.db.ExecContext(ctx, createLedger, arg.ID, arg.OwnerID, arg.OwnerType)
	return err
}

const getLedgerByOwnerID = `-- name: GetLedgerByOwnerID :one
SELECT id, owner_id, owner_type, balance, pending_balance, created_at, updated_at FROM account_ledgers
WHERE owner_id = ? AND owner_type = ?
LIMIT 1
`

type GetLedgerByOwnerIDParams struct {
	OwnerID   string                  `json:"owner_id"`
	OwnerType AccountLedgersOwnerType `json:"owner_type"`
}

func (q *Queries) GetLedgerByOwnerID(ctx context.Context, arg GetLedgerByOwnerIDParams) (AccountLedgers, error) {
	row := q.db.QueryRowContext(ctx, getLedgerByOwnerID, arg.OwnerID, arg.OwnerType)
	var i AccountLedgers
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.OwnerType,
		&i.Balance,
		&i.PendingBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLedgerBalances = `-- name: UpdateLedgerBalances :exec
UPDATE account_ledgers
SET
  balance = balance + ?,
  pending_balance = pending_balance + ?
WHERE id = ?
`

type UpdateLedgerBalancesParams struct {
	BalanceChange        string `json:"balance_change"`
	PendingBalanceChange string `json:"pending_balance_change"`
	ID                   string `json:"id"`
}

// Use positive values for CREDIT, negative for DEBIT
func (q *Queries) UpdateLedgerBalances(ctx context.Context, arg UpdateLedgerBalancesParams) error {
	_, err := q.db.ExecContext(ctx, updateLedgerBalances, arg.BalanceChange, arg.PendingBalanceChange, arg.ID)
	return err
}
