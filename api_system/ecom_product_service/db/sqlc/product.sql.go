// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const countProductsAdvanced = `-- name: CountProductsAdvanced :one
SELECT COUNT(*) AS total
FROM (
  SELECT 
    p.id
  FROM product p
  LEFT JOIN product_sku ps ON ps.product_id = p.id
  LEFT JOIN category c ON p.category_id = c.category_id
  LEFT JOIN brand b ON p.brand_id = b.brand_id
  WHERE
    (? IS NULL OR b.code = ?)
    AND (? IS NULL OR c.path =  ?)
    AND (? IS NULL OR p.shop_id = ?)
    AND (? IS NULL OR p.name LIKE CONCAT('%', ?, '%'))
  GROUP BY p.id
  HAVING
    (? IS NULL OR MAX(ps.price) >= ?)
    AND (? IS NULL OR MIN(ps.price) <= ?)
) AS t
`

type CountProductsAdvancedParams struct {
	BrandCode    sql.NullString  `json:"brand_code"`
	CategoryPath sql.NullString  `json:"category_path"`
	ShopID       sql.NullString  `json:"shop_id"`
	Keyword      interface{}     `json:"keyword"`
	PriceMin     sql.NullFloat64 `json:"price_min"`
	PriceMax     sql.NullFloat64 `json:"price_max"`
}

func (q *Queries) CountProductsAdvanced(ctx context.Context, arg CountProductsAdvancedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProductsAdvanced,
		arg.BrandCode,
		arg.BrandCode,
		arg.CategoryPath,
		arg.CategoryPath,
		arg.ShopID,
		arg.ShopID,
		arg.Keyword,
		arg.Keyword,
		arg.PriceMin,
		arg.PriceMin,
		arg.PriceMax,
		arg.PriceMax,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createProduct = `-- name: CreateProduct :exec

INSERT INTO product (
  id, name, ` + "`" + `key` + "`" + `, description, short_description,
  brand_id, category_id, shop_id,
  image, media,
   product_is_permission_return, product_is_permission_check,
  create_by
) VALUES (
  ?,
  ?,
  ?,
  ?, 
  ?, 
  ?, 
  ?,
  ?,
  ?, 
  ?, 
  COALESCE(?, TRUE),
  COALESCE(?, TRUE),
  ?
)
`

type CreateProductParams struct {
	ID                        string         `json:"id"`
	Name                      string         `json:"name"`
	Key                       string         `json:"key"`
	Description               sql.NullString `json:"description"`
	ShortDescription          sql.NullString `json:"short_description"`
	BrandID                   sql.NullString `json:"brand_id"`
	CategoryID                string         `json:"category_id"`
	ShopID                    string         `json:"shop_id"`
	Image                     string         `json:"image"`
	Media                     sql.NullString `json:"media"`
	ProductIsPermissionReturn interface{}    `json:"product_is_permission_return"`
	ProductIsPermissionCheck  interface{}    `json:"product_is_permission_check"`
	CreateBy                  sql.NullString `json:"create_by"`
}

// PRODUCT CRUD & UTILS
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.ExecContext(ctx, createProduct,
		arg.ID,
		arg.Name,
		arg.Key,
		arg.Description,
		arg.ShortDescription,
		arg.BrandID,
		arg.CategoryID,
		arg.ShopID,
		arg.Image,
		arg.Media,
		arg.ProductIsPermissionReturn,
		arg.ProductIsPermissionCheck,
		arg.CreateBy,
	)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM product WHERE id = ?
`

func (q *Queries) DeleteProduct(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getAllProductID = `-- name: GetAllProductID :many
SELECT id FROM product
`

func (q *Queries) GetAllProductID(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one
SELECT
  p.id, p.name, p.` + "`" + `key` + "`" + `, p.description, p.short_description,
  p.brand_id, p.category_id, p.shop_id,
  p.image, p.media, p.delete_status,
  p.product_is_permission_return, p.product_is_permission_check,
  p.create_date, p.update_date, p.create_by, p.update_by,
  (SELECT MIN(price) FROM product_sku WHERE product_id = p.id) AS min_price,
  (SELECT MAX(price) FROM product_sku WHERE product_id = p.id) AS max_price,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price ASC LIMIT 1) AS min_price_sku_id,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price DESC LIMIT 1) AS max_price_sku_id
FROM product p
WHERE p.id = ?
LIMIT 1
`

type GetProductRow struct {
	ID                        string                  `json:"id"`
	Name                      string                  `json:"name"`
	Key                       string                  `json:"key"`
	Description               sql.NullString          `json:"description"`
	ShortDescription          sql.NullString          `json:"short_description"`
	BrandID                   sql.NullString          `json:"brand_id"`
	CategoryID                string                  `json:"category_id"`
	ShopID                    string                  `json:"shop_id"`
	Image                     string                  `json:"image"`
	Media                     sql.NullString          `json:"media"`
	DeleteStatus              NullProductDeleteStatus `json:"delete_status"`
	ProductIsPermissionReturn sql.NullBool            `json:"product_is_permission_return"`
	ProductIsPermissionCheck  sql.NullBool            `json:"product_is_permission_check"`
	CreateDate                sql.NullTime            `json:"create_date"`
	UpdateDate                sql.NullTime            `json:"update_date"`
	CreateBy                  sql.NullString          `json:"create_by"`
	UpdateBy                  sql.NullString          `json:"update_by"`
	MinPrice                  interface{}             `json:"min_price"`
	MaxPrice                  interface{}             `json:"max_price"`
	MinPriceSkuID             string                  `json:"min_price_sku_id"`
	MaxPriceSkuID             string                  `json:"max_price_sku_id"`
}

func (q *Queries) GetProduct(ctx context.Context, id string) (GetProductRow, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i GetProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Key,
		&i.Description,
		&i.ShortDescription,
		&i.BrandID,
		&i.CategoryID,
		&i.ShopID,
		&i.Image,
		&i.Media,
		&i.DeleteStatus,
		&i.ProductIsPermissionReturn,
		&i.ProductIsPermissionCheck,
		&i.CreateDate,
		&i.UpdateDate,
		&i.CreateBy,
		&i.UpdateBy,
		&i.MinPrice,
		&i.MaxPrice,
		&i.MinPriceSkuID,
		&i.MaxPriceSkuID,
	)
	return i, err
}

const getProductByKey = `-- name: GetProductByKey :one
SELECT
  p.id, p.name, p.` + "`" + `key` + "`" + `, p.description, p.short_description,
  p.brand_id, p.category_id, p.shop_id,
  p.image, p.media, p.delete_status,
  p.product_is_permission_return, p.product_is_permission_check,
  p.create_date, p.update_date, p.create_by, p.update_by,
  (SELECT MIN(price) FROM product_sku WHERE product_id = p.id) AS min_price,
  (SELECT MAX(price) FROM product_sku WHERE product_id = p.id) AS max_price,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price ASC LIMIT 1) AS min_price_sku_id,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price DESC LIMIT 1) AS max_price_sku_id
FROM product p
WHERE p.` + "`" + `key` + "`" + ` = ?
LIMIT 1
`

type GetProductByKeyRow struct {
	ID                        string                  `json:"id"`
	Name                      string                  `json:"name"`
	Key                       string                  `json:"key"`
	Description               sql.NullString          `json:"description"`
	ShortDescription          sql.NullString          `json:"short_description"`
	BrandID                   sql.NullString          `json:"brand_id"`
	CategoryID                string                  `json:"category_id"`
	ShopID                    string                  `json:"shop_id"`
	Image                     string                  `json:"image"`
	Media                     sql.NullString          `json:"media"`
	DeleteStatus              NullProductDeleteStatus `json:"delete_status"`
	ProductIsPermissionReturn sql.NullBool            `json:"product_is_permission_return"`
	ProductIsPermissionCheck  sql.NullBool            `json:"product_is_permission_check"`
	CreateDate                sql.NullTime            `json:"create_date"`
	UpdateDate                sql.NullTime            `json:"update_date"`
	CreateBy                  sql.NullString          `json:"create_by"`
	UpdateBy                  sql.NullString          `json:"update_by"`
	MinPrice                  interface{}             `json:"min_price"`
	MaxPrice                  interface{}             `json:"max_price"`
	MinPriceSkuID             string                  `json:"min_price_sku_id"`
	MaxPriceSkuID             string                  `json:"max_price_sku_id"`
}

func (q *Queries) GetProductByKey(ctx context.Context, key string) (GetProductByKeyRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByKey, key)
	var i GetProductByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Key,
		&i.Description,
		&i.ShortDescription,
		&i.BrandID,
		&i.CategoryID,
		&i.ShopID,
		&i.Image,
		&i.Media,
		&i.DeleteStatus,
		&i.ProductIsPermissionReturn,
		&i.ProductIsPermissionCheck,
		&i.CreateDate,
		&i.UpdateDate,
		&i.CreateBy,
		&i.UpdateBy,
		&i.MinPrice,
		&i.MaxPrice,
		&i.MinPriceSkuID,
		&i.MaxPriceSkuID,
	)
	return i, err
}

const getProductIDs = `-- name: GetProductIDs :many
SELECT id, name, ` + "`" + `key` + "`" + `, description, short_description, brand_id, category_id, shop_id, image, media, delete_status, product_is_permission_return, product_is_permission_check, create_date, update_date, create_by, update_by FROM product 
WHERE id IN (/*SLICE:product_ids*/?)
`

func (q *Queries) GetProductIDs(ctx context.Context, productIds []string) ([]Product, error) {
	query := getProductIDs
	var queryParams []interface{}
	if len(productIds) > 0 {
		for _, v := range productIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:product_ids*/?", strings.Repeat(",?", len(productIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:product_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Key,
			&i.Description,
			&i.ShortDescription,
			&i.BrandID,
			&i.CategoryID,
			&i.ShopID,
			&i.Image,
			&i.Media,
			&i.DeleteStatus,
			&i.ProductIsPermissionReturn,
			&i.ProductIsPermissionCheck,
			&i.CreateDate,
			&i.UpdateDate,
			&i.CreateBy,
			&i.UpdateBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductStockTotal = `-- name: GetProductStockTotal :one
SELECT COALESCE(SUM(quantity), 0) AS total_stock
FROM product_sku
WHERE product_id = ?
`

func (q *Queries) GetProductStockTotal(ctx context.Context, productID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getProductStockTotal, productID)
	var total_stock interface{}
	err := row.Scan(&total_stock)
	return total_stock, err
}

const listProductsAdvanced = `-- name: ListProductsAdvanced :many
SELECT
  p.id,
  p.name,
  p.` + "`" + `key` + "`" + `,
  p.description,
  p.short_description,
  p.brand_id,
  p.category_id,
  p.shop_id,
  p.image,
  p.media,
  p.delete_status,
  p.product_is_permission_return,
  p.product_is_permission_check,
  p.create_date,
  p.update_date,
  p.create_by,
  p.update_by,
  COALESCE(MIN(ps.price), 0)  AS min_price,
  COALESCE(MAX(ps.price), 0)  AS max_price,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price ASC  LIMIT 1) AS min_price_sku_id,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price DESC LIMIT 1) AS max_price_sku_id
FROM product p
LEFT JOIN product_sku ps ON ps.product_id = p.id
LEFT JOIN category c ON p.category_id = c.category_id
LEFT JOIN brand b ON p.brand_id = b.brand_id
WHERE
  (? IS NULL OR b.code = ?)
  AND (? IS NULL OR c.path =  ?)
  AND (? IS NULL OR p.shop_id = ?)
  AND (? IS NULL OR p.name LIKE CONCAT('%', ?, '%'))
GROUP BY p.id
HAVING
  (? IS NULL OR MAX(ps.price) >= ?)
  AND (? IS NULL OR MIN(ps.price) <= ?)
ORDER BY
  CASE WHEN ? = 'price_asc'  THEN MIN(ps.price) END ASC,
  CASE WHEN ? = 'price_desc' THEN MIN(ps.price) END DESC,
  CASE WHEN ? = 'name_asc'   THEN p.name END ASC,
  CASE WHEN ? = 'name_desc'  THEN p.name END DESC,
  p.create_date DESC
LIMIT ?, ?
`

type ListProductsAdvancedParams struct {
	BrandCode    sql.NullString  `json:"brand_code"`
	CategoryPath sql.NullString  `json:"category_path"`
	ShopID       sql.NullString  `json:"shop_id"`
	Keyword      interface{}     `json:"keyword"`
	PriceMin     sql.NullFloat64 `json:"price_min"`
	PriceMax     sql.NullFloat64 `json:"price_max"`
	Sort         interface{}     `json:"sort"`
	Offset       int32           `json:"offset"`
	Limit        int32           `json:"limit"`
}

type ListProductsAdvancedRow struct {
	ID                        string                  `json:"id"`
	Name                      string                  `json:"name"`
	Key                       string                  `json:"key"`
	Description               sql.NullString          `json:"description"`
	ShortDescription          sql.NullString          `json:"short_description"`
	BrandID                   sql.NullString          `json:"brand_id"`
	CategoryID                string                  `json:"category_id"`
	ShopID                    string                  `json:"shop_id"`
	Image                     string                  `json:"image"`
	Media                     sql.NullString          `json:"media"`
	DeleteStatus              NullProductDeleteStatus `json:"delete_status"`
	ProductIsPermissionReturn sql.NullBool            `json:"product_is_permission_return"`
	ProductIsPermissionCheck  sql.NullBool            `json:"product_is_permission_check"`
	CreateDate                sql.NullTime            `json:"create_date"`
	UpdateDate                sql.NullTime            `json:"update_date"`
	CreateBy                  sql.NullString          `json:"create_by"`
	UpdateBy                  sql.NullString          `json:"update_by"`
	MinPrice                  interface{}             `json:"min_price"`
	MaxPrice                  interface{}             `json:"max_price"`
	MinPriceSkuID             sql.NullString          `json:"min_price_sku_id"`
	MaxPriceSkuID             sql.NullString          `json:"max_price_sku_id"`
}

func (q *Queries) ListProductsAdvanced(ctx context.Context, arg ListProductsAdvancedParams) ([]ListProductsAdvancedRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsAdvanced,
		arg.BrandCode,
		arg.BrandCode,
		arg.CategoryPath,
		arg.CategoryPath,
		arg.ShopID,
		arg.ShopID,
		arg.Keyword,
		arg.Keyword,
		arg.PriceMin,
		arg.PriceMin,
		arg.PriceMax,
		arg.PriceMax,
		arg.Sort,
		arg.Sort,
		arg.Sort,
		arg.Sort,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsAdvancedRow
	for rows.Next() {
		var i ListProductsAdvancedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Key,
			&i.Description,
			&i.ShortDescription,
			&i.BrandID,
			&i.CategoryID,
			&i.ShopID,
			&i.Image,
			&i.Media,
			&i.DeleteStatus,
			&i.ProductIsPermissionReturn,
			&i.ProductIsPermissionCheck,
			&i.CreateDate,
			&i.UpdateDate,
			&i.CreateBy,
			&i.UpdateBy,
			&i.MinPrice,
			&i.MaxPrice,
			&i.MinPriceSkuID,
			&i.MaxPriceSkuID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE product
SET
  name = COALESCE(?, name),
  ` + "`" + `key` + "`" + ` = COALESCE(?, ` + "`" + `key` + "`" + `),
  description = COALESCE(?, description),
  short_description = COALESCE(?, short_description),
  brand_id = COALESCE(?, brand_id),
  category_id = COALESCE(?, category_id),
  shop_id = COALESCE(?, shop_id),
  image = COALESCE(?, image),
  media = COALESCE(?, media),
  delete_status = COALESCE(?, delete_status),
  product_is_permission_return = COALESCE(?, product_is_permission_return),
  product_is_permission_check = COALESCE(?, product_is_permission_check),
  update_by = COALESCE(?, update_by),
  update_date = NOW()
WHERE id = ?
`

type UpdateProductParams struct {
	Name                      sql.NullString          `json:"name"`
	Key                       sql.NullString          `json:"key"`
	Description               sql.NullString          `json:"description"`
	ShortDescription          sql.NullString          `json:"short_description"`
	BrandID                   sql.NullString          `json:"brand_id"`
	CategoryID                sql.NullString          `json:"category_id"`
	ShopID                    sql.NullString          `json:"shop_id"`
	Image                     sql.NullString          `json:"image"`
	Media                     sql.NullString          `json:"media"`
	DeleteStatus              NullProductDeleteStatus `json:"delete_status"`
	ProductIsPermissionReturn sql.NullBool            `json:"product_is_permission_return"`
	ProductIsPermissionCheck  sql.NullBool            `json:"product_is_permission_check"`
	UpdateBy                  sql.NullString          `json:"update_by"`
	ID                        string                  `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.ExecContext(ctx, updateProduct,
		arg.Name,
		arg.Key,
		arg.Description,
		arg.ShortDescription,
		arg.BrandID,
		arg.CategoryID,
		arg.ShopID,
		arg.Image,
		arg.Media,
		arg.DeleteStatus,
		arg.ProductIsPermissionReturn,
		arg.ProductIsPermissionCheck,
		arg.UpdateBy,
		arg.ID,
	)
	return err
}
