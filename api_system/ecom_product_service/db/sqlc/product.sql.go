// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const countProductsAdvanced = `-- name: CountProductsAdvanced :one
SELECT COUNT(*)
FROM product p
WHERE 
    p.delete_status = 'Active'
    AND (? IS NULL OR p.shop_id = ?)
    AND (? IS NULL OR p.category_id = ?)
    AND (? IS NULL OR p.brand_id = ?)
    AND (? IS NULL OR p.min_price >= ?)
    AND (? IS NULL OR p.min_price <= ?)
    AND (? IS NULL OR p.name LIKE CONCAT('%', ?, '%'))
`

type CountProductsAdvancedParams struct {
	ShopID     sql.NullString  `json:"shop_id"`
	CategoryID sql.NullString  `json:"category_id"`
	BrandID    sql.NullString  `json:"brand_id"`
	PriceMin   sql.NullFloat64 `json:"price_min"`
	PriceMax   sql.NullFloat64 `json:"price_max"`
	Keyword    interface{}     `json:"keyword"`
}

func (q *Queries) CountProductsAdvanced(ctx context.Context, arg CountProductsAdvancedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProductsAdvanced,
		arg.ShopID,
		arg.ShopID,
		arg.CategoryID,
		arg.CategoryID,
		arg.BrandID,
		arg.BrandID,
		arg.PriceMin,
		arg.PriceMin,
		arg.PriceMax,
		arg.PriceMax,
		arg.Keyword,
		arg.Keyword,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :exec

INSERT INTO product (
  id, name, ` + "`" + `key` + "`" + `, description, short_description,
  brand_id, category_id, shop_id,
  image, media,
   product_is_permission_return, product_is_permission_check,
  create_by,delete_status
) VALUES (
  ?,
  ?,
  ?,
  ?, 
  ?, 
  ?, 
  ?,
  ?,
  ?, 
  ?, 
  COALESCE(?, TRUE),
  COALESCE(?, TRUE),
  ?,"Pending"
)
`

type CreateProductParams struct {
	ID                        string         `json:"id"`
	Name                      string         `json:"name"`
	Key                       string         `json:"key"`
	Description               sql.NullString `json:"description"`
	ShortDescription          sql.NullString `json:"short_description"`
	BrandID                   sql.NullString `json:"brand_id"`
	CategoryID                string         `json:"category_id"`
	ShopID                    string         `json:"shop_id"`
	Image                     string         `json:"image"`
	Media                     sql.NullString `json:"media"`
	ProductIsPermissionReturn interface{}    `json:"product_is_permission_return"`
	ProductIsPermissionCheck  interface{}    `json:"product_is_permission_check"`
	CreateBy                  sql.NullString `json:"create_by"`
}

// PRODUCT CRUD & UTILS
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.ExecContext(ctx, createProduct,
		arg.ID,
		arg.Name,
		arg.Key,
		arg.Description,
		arg.ShortDescription,
		arg.BrandID,
		arg.CategoryID,
		arg.ShopID,
		arg.Image,
		arg.Media,
		arg.ProductIsPermissionReturn,
		arg.ProductIsPermissionCheck,
		arg.CreateBy,
	)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM product WHERE id = ?
`

func (q *Queries) DeleteProduct(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getAllProductID = `-- name: GetAllProductID :many
SELECT id FROM product
`

func (q *Queries) GetAllProductID(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllProductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one
SELECT
  p.id, p.name, p.` + "`" + `key` + "`" + `, p.description, p.short_description,
  p.brand_id, p.category_id, p.shop_id,
  p.image, p.media, p.delete_status,
  p.product_is_permission_return, p.product_is_permission_check,
  p.create_date, p.update_date, p.create_by, p.update_by,
  (SELECT MIN(price) FROM product_sku WHERE product_id = p.id) AS min_price,
  (SELECT MAX(price) FROM product_sku WHERE product_id = p.id) AS max_price,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price ASC LIMIT 1) AS min_price_sku_id,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price DESC LIMIT 1) AS max_price_sku_id
FROM product p
WHERE p.id = ?
LIMIT 1
`

type GetProductRow struct {
	ID                        string                  `json:"id"`
	Name                      string                  `json:"name"`
	Key                       string                  `json:"key"`
	Description               sql.NullString          `json:"description"`
	ShortDescription          sql.NullString          `json:"short_description"`
	BrandID                   sql.NullString          `json:"brand_id"`
	CategoryID                string                  `json:"category_id"`
	ShopID                    string                  `json:"shop_id"`
	Image                     string                  `json:"image"`
	Media                     sql.NullString          `json:"media"`
	DeleteStatus              NullProductDeleteStatus `json:"delete_status"`
	ProductIsPermissionReturn sql.NullBool            `json:"product_is_permission_return"`
	ProductIsPermissionCheck  sql.NullBool            `json:"product_is_permission_check"`
	CreateDate                sql.NullTime            `json:"create_date"`
	UpdateDate                sql.NullTime            `json:"update_date"`
	CreateBy                  sql.NullString          `json:"create_by"`
	UpdateBy                  sql.NullString          `json:"update_by"`
	MinPrice                  interface{}             `json:"min_price"`
	MaxPrice                  interface{}             `json:"max_price"`
	MinPriceSkuID             string                  `json:"min_price_sku_id"`
	MaxPriceSkuID             string                  `json:"max_price_sku_id"`
}

func (q *Queries) GetProduct(ctx context.Context, id string) (GetProductRow, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i GetProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Key,
		&i.Description,
		&i.ShortDescription,
		&i.BrandID,
		&i.CategoryID,
		&i.ShopID,
		&i.Image,
		&i.Media,
		&i.DeleteStatus,
		&i.ProductIsPermissionReturn,
		&i.ProductIsPermissionCheck,
		&i.CreateDate,
		&i.UpdateDate,
		&i.CreateBy,
		&i.UpdateBy,
		&i.MinPrice,
		&i.MaxPrice,
		&i.MinPriceSkuID,
		&i.MaxPriceSkuID,
	)
	return i, err
}

const getProductByKey = `-- name: GetProductByKey :one
SELECT
  p.id, p.name, p.` + "`" + `key` + "`" + `, p.description, p.short_description,
  p.brand_id, p.category_id, p.shop_id,
  p.image, p.media, p.delete_status,
  p.product_is_permission_return, p.product_is_permission_check,
  p.create_date, p.update_date, p.create_by, p.update_by,
  (SELECT MIN(price) FROM product_sku WHERE product_id = p.id) AS min_price,
  (SELECT MAX(price) FROM product_sku WHERE product_id = p.id) AS max_price,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price ASC LIMIT 1) AS min_price_sku_id,
  (SELECT id FROM product_sku WHERE product_id = p.id ORDER BY price DESC LIMIT 1) AS max_price_sku_id
FROM product p
WHERE p.` + "`" + `key` + "`" + ` = ?
LIMIT 1
`

type GetProductByKeyRow struct {
	ID                        string                  `json:"id"`
	Name                      string                  `json:"name"`
	Key                       string                  `json:"key"`
	Description               sql.NullString          `json:"description"`
	ShortDescription          sql.NullString          `json:"short_description"`
	BrandID                   sql.NullString          `json:"brand_id"`
	CategoryID                string                  `json:"category_id"`
	ShopID                    string                  `json:"shop_id"`
	Image                     string                  `json:"image"`
	Media                     sql.NullString          `json:"media"`
	DeleteStatus              NullProductDeleteStatus `json:"delete_status"`
	ProductIsPermissionReturn sql.NullBool            `json:"product_is_permission_return"`
	ProductIsPermissionCheck  sql.NullBool            `json:"product_is_permission_check"`
	CreateDate                sql.NullTime            `json:"create_date"`
	UpdateDate                sql.NullTime            `json:"update_date"`
	CreateBy                  sql.NullString          `json:"create_by"`
	UpdateBy                  sql.NullString          `json:"update_by"`
	MinPrice                  interface{}             `json:"min_price"`
	MaxPrice                  interface{}             `json:"max_price"`
	MinPriceSkuID             string                  `json:"min_price_sku_id"`
	MaxPriceSkuID             string                  `json:"max_price_sku_id"`
}

func (q *Queries) GetProductByKey(ctx context.Context, key string) (GetProductByKeyRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByKey, key)
	var i GetProductByKeyRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Key,
		&i.Description,
		&i.ShortDescription,
		&i.BrandID,
		&i.CategoryID,
		&i.ShopID,
		&i.Image,
		&i.Media,
		&i.DeleteStatus,
		&i.ProductIsPermissionReturn,
		&i.ProductIsPermissionCheck,
		&i.CreateDate,
		&i.UpdateDate,
		&i.CreateBy,
		&i.UpdateBy,
		&i.MinPrice,
		&i.MaxPrice,
		&i.MinPriceSkuID,
		&i.MaxPriceSkuID,
	)
	return i, err
}

const getProductIDs = `-- name: GetProductIDs :many
SELECT id, name, ` + "`" + `key` + "`" + `, description, short_description, brand_id, category_id, shop_id, image, media, delete_status, product_is_permission_return, product_is_permission_check, create_date, update_date, create_by, update_by, total_sold, min_price, max_price FROM product 
WHERE id IN (/*SLICE:product_ids*/?)
`

func (q *Queries) GetProductIDs(ctx context.Context, productIds []string) ([]Product, error) {
	query := getProductIDs
	var queryParams []interface{}
	if len(productIds) > 0 {
		for _, v := range productIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:product_ids*/?", strings.Repeat(",?", len(productIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:product_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Key,
			&i.Description,
			&i.ShortDescription,
			&i.BrandID,
			&i.CategoryID,
			&i.ShopID,
			&i.Image,
			&i.Media,
			&i.DeleteStatus,
			&i.ProductIsPermissionReturn,
			&i.ProductIsPermissionCheck,
			&i.CreateDate,
			&i.UpdateDate,
			&i.CreateBy,
			&i.UpdateBy,
			&i.TotalSold,
			&i.MinPrice,
			&i.MaxPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductStockTotal = `-- name: GetProductStockTotal :one
SELECT COALESCE(SUM(quantity), 0) AS total_stock
FROM product_sku
WHERE product_id = ?
`

func (q *Queries) GetProductStockTotal(ctx context.Context, productID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getProductStockTotal, productID)
	var total_stock interface{}
	err := row.Scan(&total_stock)
	return total_stock, err
}

const incrementProductTotalSold = `-- name: IncrementProductTotalSold :exec
UPDATE product
SET 
  total_sold = total_sold + ?,
  update_date = NOW()
WHERE id = ?
`

type IncrementProductTotalSoldParams struct {
	Quantity int64  `json:"quantity"`
	ID       string `json:"id"`
}

func (q *Queries) IncrementProductTotalSold(ctx context.Context, arg IncrementProductTotalSoldParams) error {
	_, err := q.db.ExecContext(ctx, incrementProductTotalSold, arg.Quantity, arg.ID)
	return err
}

const listProductsAdvanced = `-- name: ListProductsAdvanced :many
SELECT 
    p.id,
    p.name,
    p.` + "`" + `key` + "`" + `,
    p.description,
    p.short_description,
    p.brand_id,
    p.category_id,
    p.shop_id,
    p.image,
    p.media,
    p.delete_status,
    p.product_is_permission_return,
    p.product_is_permission_check,
    p.create_date,
    p.update_date,
    p.create_by,
    p.update_by,
    p.total_sold,
    p.min_price,
    p.max_price,
    -- Subquery lấy SKU ID đại diện (giữ nguyên logic tối ưu)
    (SELECT ps.id FROM product_sku ps WHERE ps.product_id = p.id ORDER BY ps.price ASC LIMIT 1) AS min_price_sku_id,
    (SELECT ps.id FROM product_sku ps WHERE ps.product_id = p.id ORDER BY ps.price DESC LIMIT 1) AS max_price_sku_id
FROM product p
WHERE 
    (? IS NULL OR p.delete_status = ?)
    -- Bộ lọc động (Dynamic Filtering)
    AND (? IS NULL OR p.shop_id = ?)
    AND (? IS NULL OR p.category_id = ?)
    AND (? IS NULL OR p.brand_id = ?)
    AND (? IS NULL OR p.min_price >= ?)
    AND (? IS NULL OR p.min_price <= ?)
    -- Tìm kiếm (Lưu ý: Nếu cột name là VARCHAR(255) có index, hiệu năng sẽ tốt hơn TEXT)
    AND (? IS NULL OR p.name LIKE CONCAT('%', ?, '%'))
ORDER BY 
    -- Sắp xếp động (Dynamic Sorting)
    CASE WHEN ? = 'best_sell'  THEN p.total_sold END DESC,
    CASE WHEN ? = 'price_asc'  THEN p.min_price END ASC,
    CASE WHEN ? = 'price_desc' THEN p.min_price END DESC,
    CASE WHEN ? = 'name_asc'   THEN p.name END ASC,
    CASE WHEN ? = 'name_desc'  THEN p.name END DESC,
    p.create_date DESC -- Mặc định sắp xếp theo mới nhất nếu không chọn gì
LIMIT ? OFFSET ?
`

type ListProductsAdvancedParams struct {
	DeleteStatus NullProductDeleteStatus `json:"delete_status"`
	ShopID       sql.NullString          `json:"shop_id"`
	CategoryID   sql.NullString          `json:"category_id"`
	BrandID      sql.NullString          `json:"brand_id"`
	PriceMin     sql.NullFloat64         `json:"price_min"`
	PriceMax     sql.NullFloat64         `json:"price_max"`
	Keyword      interface{}             `json:"keyword"`
	Sort         interface{}             `json:"sort"`
	Limit        int32                   `json:"limit"`
	Offset       int32                   `json:"offset"`
}

type ListProductsAdvancedRow struct {
	ID                        string                  `json:"id"`
	Name                      string                  `json:"name"`
	Key                       string                  `json:"key"`
	Description               sql.NullString          `json:"description"`
	ShortDescription          sql.NullString          `json:"short_description"`
	BrandID                   sql.NullString          `json:"brand_id"`
	CategoryID                string                  `json:"category_id"`
	ShopID                    string                  `json:"shop_id"`
	Image                     string                  `json:"image"`
	Media                     sql.NullString          `json:"media"`
	DeleteStatus              NullProductDeleteStatus `json:"delete_status"`
	ProductIsPermissionReturn sql.NullBool            `json:"product_is_permission_return"`
	ProductIsPermissionCheck  sql.NullBool            `json:"product_is_permission_check"`
	CreateDate                sql.NullTime            `json:"create_date"`
	UpdateDate                sql.NullTime            `json:"update_date"`
	CreateBy                  sql.NullString          `json:"create_by"`
	UpdateBy                  sql.NullString          `json:"update_by"`
	TotalSold                 int64                   `json:"total_sold"`
	MinPrice                  sql.NullFloat64         `json:"min_price"`
	MaxPrice                  sql.NullFloat64         `json:"max_price"`
	MinPriceSkuID             string                  `json:"min_price_sku_id"`
	MaxPriceSkuID             string                  `json:"max_price_sku_id"`
}

func (q *Queries) ListProductsAdvanced(ctx context.Context, arg ListProductsAdvancedParams) ([]ListProductsAdvancedRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsAdvanced,
		arg.DeleteStatus,
		arg.DeleteStatus,
		arg.ShopID,
		arg.ShopID,
		arg.CategoryID,
		arg.CategoryID,
		arg.BrandID,
		arg.BrandID,
		arg.PriceMin,
		arg.PriceMin,
		arg.PriceMax,
		arg.PriceMax,
		arg.Keyword,
		arg.Keyword,
		arg.Sort,
		arg.Sort,
		arg.Sort,
		arg.Sort,
		arg.Sort,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsAdvancedRow
	for rows.Next() {
		var i ListProductsAdvancedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Key,
			&i.Description,
			&i.ShortDescription,
			&i.BrandID,
			&i.CategoryID,
			&i.ShopID,
			&i.Image,
			&i.Media,
			&i.DeleteStatus,
			&i.ProductIsPermissionReturn,
			&i.ProductIsPermissionCheck,
			&i.CreateDate,
			&i.UpdateDate,
			&i.CreateBy,
			&i.UpdateBy,
			&i.TotalSold,
			&i.MinPrice,
			&i.MaxPrice,
			&i.MinPriceSkuID,
			&i.MaxPriceSkuID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE product
SET
  name = COALESCE(?, name),
  ` + "`" + `key` + "`" + ` = COALESCE(?, ` + "`" + `key` + "`" + `),
  description = COALESCE(?, description),
  short_description = COALESCE(?, short_description),
  brand_id = COALESCE(?, brand_id),
  category_id = COALESCE(?, category_id),
  shop_id = COALESCE(?, shop_id),
  image = COALESCE(?, image),
  media = COALESCE(?, media),
  delete_status = COALESCE(?, delete_status),
  product_is_permission_return = COALESCE(?, product_is_permission_return),
  product_is_permission_check = COALESCE(?, product_is_permission_check),
  update_by = COALESCE(?, update_by),
  update_date = NOW()
WHERE id = ?
`

type UpdateProductParams struct {
	Name                      sql.NullString          `json:"name"`
	Key                       sql.NullString          `json:"key"`
	Description               sql.NullString          `json:"description"`
	ShortDescription          sql.NullString          `json:"short_description"`
	BrandID                   sql.NullString          `json:"brand_id"`
	CategoryID                sql.NullString          `json:"category_id"`
	ShopID                    sql.NullString          `json:"shop_id"`
	Image                     sql.NullString          `json:"image"`
	Media                     sql.NullString          `json:"media"`
	DeleteStatus              NullProductDeleteStatus `json:"delete_status"`
	ProductIsPermissionReturn sql.NullBool            `json:"product_is_permission_return"`
	ProductIsPermissionCheck  sql.NullBool            `json:"product_is_permission_check"`
	UpdateBy                  sql.NullString          `json:"update_by"`
	ID                        string                  `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.ExecContext(ctx, updateProduct,
		arg.Name,
		arg.Key,
		arg.Description,
		arg.ShortDescription,
		arg.BrandID,
		arg.CategoryID,
		arg.ShopID,
		arg.Image,
		arg.Media,
		arg.DeleteStatus,
		arg.ProductIsPermissionReturn,
		arg.ProductIsPermissionCheck,
		arg.UpdateBy,
		arg.ID,
	)
	return err
}
